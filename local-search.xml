<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Pytest学习笔记</title>
    <link href="/post/12411/"/>
    <url>/post/12411/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Pytest 是 Python 中最流行的测试框架之一，它功能强大、灵活且易于使用，适合编写单元测试和功能测试，同时支持复杂的测试场景。</p><p>注意：笔者这里的<strong>功能测试也包括了“自动化测试”</strong>。这里的分类方式是从<strong>测试实施方式</strong>的角度来划分的。本文主要讨论Pytest在自动化测试的应用。</p><p>技术栈：Pytest + Selenium + ChromeDirver + Allure</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>在pytest中，<code>assert</code> 是编写测试的最基础工具，其实就是可以直接看成判断语句，如果为True则说明“测试通过”，如果为False则为“测试失败”。</p><h3 id="标记函数"><a href="#标记函数" class="headerlink" title="标记函数"></a>标记函数</h3><p>在学习标记函数之前，我们需要理解一个概念，<strong>测试函数</strong>和<strong>函数</strong>的区别。</p><ul><li>测试函数是用于验证被测代码是否按照预期运行的函数，通常由测试框架（如 <code>pytest</code>）<strong>自动识别</strong>并调用。</li><li>普通函数是为实现特定业务逻辑或辅助功能而定义的函数。</li></ul><p>那既然需要自动识别，那就要知道在怎么样的规则下，一个函数会被识别为测试函数呢？</p><h4 id="查找测试策略"><a href="#查找测试策略" class="headerlink" title="查找测试策略"></a>查找测试策略</h4><p>在默认情况下，pytest会递归查找当前目录下所有以 <code>test</code>开始或结束的Python脚本，并执行文件内所有以 <code>test</code>开始或结束的函数和方法。</p><h4 id="标记的作用"><a href="#标记的作用" class="headerlink" title="标记的作用"></a>标记的作用</h4><p>什么是标记，为什么要标记？一定是需要说明这个函数的特殊性，才需要标记对吧。</p><p>在此之前，我们先提供一段测试代码，供解析。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># @filename: test_login</span><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> pytest<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-keyword">from</span> utils.csvv <span class="hljs-keyword">import</span> *<span class="hljs-meta">@pytest.fixture()</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">driver</span>():    driver = webdriver.Chrome()    driver.implicitly_wait(<span class="hljs-number">10</span>)    driver.maximize_window()    <span class="hljs-comment"># Pytest 使用 yield 关键词将固件分为两部分，yield 之前的代码属于预处理，</span>    <span class="hljs-comment"># 会在测试前执行；yield 之后的代码属于后处理，将在测试完成后执行。</span>    <span class="hljs-keyword">yield</span> driver    driver.quit()<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_login_data</span>():    <span class="hljs-keyword">return</span> read_csv(<span class="hljs-string">&#x27;./IndustryContest/data/data.csv&#x27;</span>, <span class="hljs-literal">False</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login</span>(<span class="hljs-params">driver</span>):    driver.get(<span class="hljs-string">&quot;http://apisp.com&quot;</span>)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入公司代码&quot;]&#x27;</span>).send_keys(<span class="hljs-string">&quot;88888888&quot;</span>)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入用户名&quot;]&#x27;</span>).send_keys(<span class="hljs-string">&quot;admin&quot;</span>)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入密码&quot;]&#x27;</span>).send_keys(<span class="hljs-string">&quot;123456&quot;</span>)    driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;el-button&quot;</span>).click()    result = driver.find_element(By.CLASS_NAME, <span class="hljs-string">&#x27;el-message__content&#x27;</span>).text    <span class="hljs-keyword">assert</span> result == <span class="hljs-string">&#x27;登录成功,正在跳转!&#x27;</span>    time.sleep(<span class="hljs-number">10</span>)<span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;code, username, password, result&quot;</span>, read_login_data(<span class="hljs-params"></span>)</span>)</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_data_driver_login</span>(<span class="hljs-params">driver, code, username, password, result</span>):    driver.get(<span class="hljs-string">&quot;http://apisp.com&quot;</span>)    time.sleep(<span class="hljs-number">3</span>)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入公司代码&quot;]&#x27;</span>).send_keys(code)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入用户名&quot;]&#x27;</span>).send_keys(username)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入密码&quot;]&#x27;</span>).send_keys(password)    driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;el-button&quot;</span>).click()    time.sleep(<span class="hljs-number">3</span>)    actual = driver.find_element(By.CLASS_NAME, <span class="hljs-string">&#x27;el-message__content&#x27;</span>).text    <span class="hljs-keyword">assert</span> actual == result    time.sleep(<span class="hljs-number">10</span>)</code></pre></div><p>例如，我们有一个 <code>test_func2</code>函数，里面的功能尚未开发完成，我们只想要<strong>执行指定的测试函数</strong>（这个过程可以称为测试控制）。有以下几种方式可以解决：</p><p><strong>方法一：</strong>显式指定函数名，通过 <code>::</code> 进行标记。例如我们执行 <code>test_data_driver_login</code></p><div class="code-wrapper"><pre><code class="hljs autohotkey"><span class="hljs-title">pytest test_login.py::</span>test_dat<span class="hljs-built_in">a_driver</span>_login</code></pre></div><p><strong>方法二：</strong>使用模糊匹配的方式，使用 <code>-k</code> 选项进行标识。</p><div class="code-wrapper"><pre><code class="hljs shell">pytest test_login.py -k data</code></pre></div><blockquote><p>[!NOTE]</p><p>以上两种方法，第一种一次只能指定一个测试函数，但是需要进行批量测试的时候不可行；第二种方法可以进行批量操作，但是需要所有测试函数，函数名都包含相同的模式。</p></blockquote><p><strong>方法三：</strong>使用 <code>pytest.mark</code> 在函数上进行标记。</p><p>例如，我需要标记 <code>test_data_driver_login</code> 这个函数为未完成的函数，在执行测试的时候，自动跳过。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.unfinished</span><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;code, username, password, result&quot;</span>, read_login_data(<span class="hljs-params"></span>)</span>)</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_data_driver_login</span>(<span class="hljs-params">driver, code, username, password, result</span>):    driver.get(<span class="hljs-string">&quot;http://apisp.com&quot;</span>)    time.sleep(<span class="hljs-number">3</span>)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入公司代码&quot;]&#x27;</span>).send_keys(code)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入用户名&quot;]&#x27;</span>).send_keys(username)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入密码&quot;]&#x27;</span>).send_keys(password)    driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;el-button&quot;</span>).click()    time.sleep(<span class="hljs-number">3</span>)    actual = driver.find_element(By.CLASS_NAME, <span class="hljs-string">&#x27;el-message__content&#x27;</span>).text    <span class="hljs-keyword">assert</span> actual == result    time.sleep(<span class="hljs-number">10</span>)</code></pre></div><p>我只需要在函数之前加上 <code>pytest.mark.unfinished</code> 这个标记，并且在执行测试的时候，加上 <code>-m</code> 选项。因此只需要执行</p><div class="code-wrapper"><pre><code class="hljs shell">pytest test_login.py -m &#x27;not unfinished&#x27;</code></pre></div><p>没错，是可以使用布尔运算符的。</p><h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><p>遇到那些尚未开发完的测试，最好的解决方案就是略过而不执行测试。</p><p>按照正向的思路，我们只需要通过标记制定的需要测试的函数即可；但是有时候，我们可以进行反向操作才可以达成最好的解决途径，即通过标记指定需要跳过的测试。</p><p>Pytest需要使用特定的标记  <code>pytest.mark.skip</code> 即可标记需要跳过的测试。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.skip(<span class="hljs-params">reason=<span class="hljs-string">&#x27;out-of-date api&#x27;</span></span>)</span><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;code, username, password, result&quot;</span>, read_login_data(<span class="hljs-params"></span>)</span>)</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_data_driver_login</span>(<span class="hljs-params">driver, code, username, password, result</span>):    driver.get(<span class="hljs-string">&quot;http://apisp.com&quot;</span>)    time.sleep(<span class="hljs-number">3</span>)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入公司代码&quot;]&#x27;</span>).send_keys(code)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入用户名&quot;]&#x27;</span>).send_keys(username)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入密码&quot;]&#x27;</span>).send_keys(password)    driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;el-button&quot;</span>).click()    time.sleep(<span class="hljs-number">3</span>)    actual = driver.find_element(By.CLASS_NAME, <span class="hljs-string">&#x27;el-message__content&#x27;</span>).text    <span class="hljs-keyword">assert</span> actual == result    time.sleep(<span class="hljs-number">10</span>)</code></pre></div><p>即可跳过测试。</p><p>同时Pytest 还支持使用 <code>pytest.mark.skipif</code> 为测试函数指定被忽略的条件。</p><h3 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h3><p>当一个测试函数进行测试的时候，可能会给函数传递多组参数，例如测试账号的登录，可能需要模拟各种千奇百怪的测试和密码。</p><p>我们可以写一个 <code>[]</code> 然后在测试函数内部遍历，但是仍然是在一个测试函数内，如果某组测试数据发生错误，导致了断言失败，测试就会终止。</p><p>当然你肯定也知道断言错误的结果是一个异常，可以通过异常处理来保证测试数据能够被完整执行，但是分析测试结果这个过程，就需要不少的额外工作。</p><p>因此，参数化测试就是能够解决这个问题的关键，每组参数都独立执行一次测试，使用 <code>pytest.mark.parametrize(argnames,argvalues)</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;code&quot;</span>, [<span class="hljs-string">&#x27;8888888&#x27;</span>,<span class="hljs-string">&#x27;88888888&#x27;</span>,<span class="hljs-string">&#x27;88888888&#x27;</span>]</span>)</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_data_driver_login</span>(<span class="hljs-params">driver, code</span>):    driver.get(<span class="hljs-string">&quot;http://apisp.com&quot;</span>)    time.sleep(<span class="hljs-number">3</span>)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入公司代码&quot;]&#x27;</span>).send_keys(code)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入用户名&quot;]&#x27;</span>).send_keys(<span class="hljs-string">&quot;admin&quot;</span>)    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//input[@placeholder=&quot;请输入密码&quot;]&#x27;</span>).send_keys(<span class="hljs-string">&quot;123456&quot;</span>)    driver.find_element(By.CLASS_NAME, <span class="hljs-string">&quot;el-button&quot;</span>).click()    time.sleep(<span class="hljs-number">3</span>)    actual = driver.find_element(By.CLASS_NAME, <span class="hljs-string">&#x27;el-message__content&#x27;</span>).text    <span class="hljs-keyword">assert</span> actual == result    time.sleep(<span class="hljs-number">10</span>)</code></pre></div><p>例如以上的代码，将会执行3次。同时被pytest记录。当然我们也可以传入多个参数。</p><p>当然，按照实际遇到的环境，我们肯定不会把测试数据写在测试类的头上，如果多个测试函数需要使用同一测试数据，那修改维护是一件很让人头痛的事情。</p><p><strong>因此，我们需要把测试数据单独抽离出来，独立维护。</strong></p><p>我们常规会使用一份 <code>csv</code>文件，来保存我们的测试数据。通过使用读取CSV文件的数据，将其转换为Python对象。下面是一段示例代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_csv</span>(<span class="hljs-params">filename, removeStartLine=<span class="hljs-literal">True</span></span>):    data = []    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:        reader = csv.reader(f,delimiter=<span class="hljs-string">&#x27;，&#x27;</span>)        <span class="hljs-keyword">if</span> removeStartLine:            <span class="hljs-built_in">next</span>(reader)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:            data.append(row)    <span class="hljs-keyword">return</span> data</code></pre></div><p>注意，这里可以使用 <code>delimiter</code>参数来解决，如果CSV文件的默认分隔符（<code>,</code>）和文本冲突的问题。</p><h3 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h3><p>固件（Fixture）是一些函数，pytest将会在执行测试函数之前或之后执行他们。</p><h4 id="预处理和后处理"><a href="#预处理和后处理" class="headerlink" title="预处理和后处理"></a>预处理和后处理</h4><p>很多时候都需要在测试之前进行预处理（例如新建数据库链接、初始化Selenium浏览器），并在测试完成后进行清理。这时候最好的方法是使用固件来自动化所有预处理和后处理。</p><p>Pytest中使用 <code>yield</code>关键词将固件分为两个部分，<code>yield</code> 之前的代码属于预处理，会在测试前执行；<code>yield</code> 之后的代码属于后处理，将在测试完成后执行。例如</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture()</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">driver</span>():    driver = webdriver.Chrome()    driver.implicitly_wait(<span class="hljs-number">10</span>)    driver.maximize_window()    <span class="hljs-keyword">yield</span> driver    driver.quit()</code></pre></div><p>例如以上代码，前半部分进行初始化，后半部分进行浏览器的关闭。</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>固件的作用是为了抽离重复的工作和方便复用，为了更加精细化控制固件，例如我想要在每次测试都开启或关闭一次浏览器。</p><p>因此，在定义固件时，通过 <code>scope</code> 参数声明作用域，可选项有：</p><ul><li><code>function</code>: 函数级，每个测试函数都会执行一次固件；</li><li><code>class</code>: 类级别，每个测试类执行一次，所有方法都可以使用；</li><li><code>module</code>: 模块级，每个模块执行一次，模块内函数和方法都可使用；</li><li><code>session</code>: 会话级，一次测试只执行一次，所有被找到的函数和方法都可用。</li></ul><p>默认的作用域为 <code>function</code></p><h3 id="PageObject怎么办？"><a href="#PageObject怎么办？" class="headerlink" title="PageObject怎么办？"></a>PageObject怎么办？</h3><p>其实也一样，要明白<strong>PageObject思想的核心</strong>，其他的只是在基础上进行进一步的抽象，解耦。</p><p>其实就是以页面为核心，封装页面的各种操作，例如<strong>打开菜单、输入内容</strong>等。然而，为了使这些操作便与维护，因此实现一个继承类是很有必要的。所以要求每个页面从BasePage中继承基本操作，然后有逐个的特性。</p><p>例如在BasePage中封装打开页面、元素查找等功能。然后其他页面继承自BasePage，并进行特殊的操作。然后在每个Page中暴露出一个测试方法，可供外部测试函数进行调用。</p><p>其他的就是继续抽象结耦。</p>]]></content>
    
    
    <categories>
      
      <category>软测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Node.js实现WebSocket服务器</title>
    <link href="/post/27328/"/>
    <url>/post/27328/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="基于Node-js实现WebSocket服务器"><a href="#基于Node-js实现WebSocket服务器" class="headerlink" title="基于Node.js实现WebSocket服务器"></a>基于Node.js实现WebSocket服务器</h1><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是HTML5新增的协议，它的作用是在<strong>浏览器与服务器</strong>之间建立一个不受限制的<strong>双向通信</strong>的通道。注意，其中双方可以在连接后的任意时刻，进行消息的互相传递。</p><p>HTTP协议是一个请求-响应的协议。请求必须由浏览器（或其他，例如Postman）发给服务器，然后服务器才能响应这个请求，将数据发送给浏览器。通俗一点说，如果浏览器不主动发送请求，服务器是不会主动发送数据给浏览器的。</p><p>例如，以下的代码使用express框架给出了一个简单的HTTP请求处理。</p><p><img src="https://s2.loli.net/2024/08/20/EhDP6TaWJ973r2F.png" alt="express框架HTTP请求处理"></p><p><code>get</code> 函数接受两个参数，一个是path(访问路径)，然后是一个回调函数，回调函数接受两个参数，req代表收到的请求（request），res表示响应（response）。</p><h3 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h3><p>为了方便调试，我们先使用Postman来做一个简单的请求发送，</p><p><img src="https://s2.loli.net/2024/08/20/mbgWuTQMIklxHrX.png" alt="Postman调试界面"></p><p>差不多就是这样，我们可以看到右侧的连接状态是CONNECTED，表示已经连接成功。</p><p>我们可以看到下面的控制台打印的请求参数，包括了请求URL等。</p><p>WebSocket 是一种全双工通信协议，通常通过 <code>ws://</code> 或 <code>wss://</code>（加密的 WebSocket）协议进行通信。</p><ul><li><strong>请求方式</strong>：WebSocket 使用 HTTP&#x2F;1.1 协议作为握手（Handshake）协议，客户端发起的初始连接请求是一个标准的 HTTP 请求，但带有一些特殊的头字段。</li><li><strong>响应方式</strong>：服务器在收到 WebSocket 握手请求后，如果同意升级协议，会返回一个 101 Switching Protocols 的响应，表示协议升级成功。此后，通信改为 WebSocket 协议，而不再使用 HTTP。</li></ul><p><strong>那为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？</strong></p><p>实际上HTTP协议是建立在TCP协议之上的，<strong>TCP协议本身就实现了全双工通信</strong>，但是，由于HTTP协议的请求-应答机制就限制了全双工通信。当WebSocket连接建立后，只是简单的规定（互相约定）了一下：接下来我们就不使用HTTP协议了，直接互相发数据吧。</p><h3 id="浏览器层"><a href="#浏览器层" class="headerlink" title="浏览器层"></a>浏览器层</h3><p>目前，对于WebSocket协议来说，在浏览器层面，是作为客户端的。WebSocket目前 已经在绝大多数主流浏览器中得到了广泛的支持，无论是桌面浏览器还是移动端浏览器。只要用户使用的是较新的浏览器版本，WebSocket 功能通常都是可用的。对于极少数不支持 WebSocket 的旧版浏览器，可以考虑使用 Polyfill 或回退到轮询技术（如 AJAX 或 Long Polling）。</p><h3 id="服务器层"><a href="#服务器层" class="headerlink" title="服务器层"></a>服务器层</h3><p>由于WebSocket是一个协议，准确来说是基于HTTP的协议，服务器层面如何实现，取决于所使用的编程语言和框架本身。目前Node.js支持TCP协议和HTTP协议，但是需要支持WebSocket协议，需要用到其他模块。</p><h3 id="使用ws实现"><a href="#使用ws实现" class="headerlink" title="使用ws实现"></a>使用ws实现</h3><p>如果要使用WebSocket，关键在于服务器端支持。目前使用最为广泛的WebSocket模块是 <code>ws</code></p><p>下面是基础代码</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ws&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocketServer</span> = <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">Server</span>;<span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServer</span>(&#123;    <span class="hljs-attr">port</span>: <span class="hljs-number">4000</span>&#125;);wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ws</span>) =&gt;</span> &#123;    ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received: <span class="hljs-subst">$&#123;message&#125;</span>`</span>);        ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">`Echo: <span class="hljs-subst">$&#123;message&#125;</span>`</span>);    &#125;);    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Connected to server.&#x27;</span>);&#125;);</code></pre></div><p>首先我们使用 <code>wss</code> 来保存 <code>WebSocketServer</code> 实例。然后我们开始对 <code>wss</code> 注册监听事件。</p><p>当连接的时候，我们可以拿到 <code>ws</code> 实例对象，然后在其中进行当接收到消息的处理。我们也可以将消息返回给客户端。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XPath怎么写？</title>
    <link href="/post/18945/"/>
    <url>/post/18945/</url>
    
    <content type="html"><![CDATA[<h3 id="Xpath-怎么写？"><a href="#Xpath-怎么写？" class="headerlink" title="Xpath 怎么写？"></a>Xpath 怎么写？</h3><h5 id="1-标签名"><a href="#1-标签名" class="headerlink" title="1. 标签名"></a>1. 标签名</h5><div class="code-wrapper"><pre><code class="hljs html">//标签名例如：//button，所有标签名为button的元素即：<span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>我是一个按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div><h5 id="2-标签名-节点属性定位"><a href="#2-标签名-节点属性定位" class="headerlink" title="2. 标签名+节点属性定位"></a>2. 标签名+节点属性定位</h5><div class="code-wrapper"><pre><code class="hljs html">//标签名[@属性名=属性值]例如：//button[@id=username]，id为username的button标签即：<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>我是一个按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div><h5 id="3-得到某个元素的所有子元素"><a href="#3-得到某个元素的所有子元素" class="headerlink" title="3. 得到某个元素的所有子元素"></a>3. 得到某个元素的所有子元素</h5><p>例如有如下的HTML内容。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>C++<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>PHP<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;6&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;7&quot;</span>&gt;</span>HTML<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span>CSS<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>我只需要使用 <code>*</code> 这个通配符即可完成匹配。下面的XPATH即为匹配 <code>select</code> 下的所有子元素。</p><div class="code-wrapper"><pre><code class="hljs html">//select/*</code></pre></div><h5 id="4-得到某个索引值下的元素"><a href="#4-得到某个索引值下的元素" class="headerlink" title="4. 得到某个索引值下的元素"></a>4. 得到某个索引值下的元素</h5><p>如上例，想要得到第3个选项的 <code>&lt;option value=&quot;3&quot;&gt;Java&lt;/option&gt;</code> 即这个元素</p><div class="code-wrapper"><pre><code class="hljs 1c"><span class="hljs-comment">//select/*[3]</span></code></pre></div><p><strong>请注意XPATH语法的索引值是从1开始的！</strong></p><p>那么，我想要得到最后一个 <code>&lt;option&gt;</code>  元素？</p><div class="code-wrapper"><pre><code class="hljs html">//select/*[last()]</code></pre></div><p>只要在下标索引的地方 <code>last()</code> 即可，但是需要<strong>注意，没有first()</strong></p><p>那我想要多个匹配呢？？例如，我想要匹配前两个 <code>&lt;option&gt;</code> 元素。</p><div class="code-wrapper"><pre><code class="hljs html">//select/*[position() &lt; 3]</code></pre></div><p>位置函数 <code>position()</code> 匹配，位置小于3的元素。</p><h5 id="5-元素的条件定位"><a href="#5-元素的条件定位" class="headerlink" title="5. 元素的条件定位"></a>5. 元素的条件定位</h5><p>在XPATH的语法中，我们可以使用 <code>!</code> 、<code>and</code> 、<code>or</code> 这三个基础逻辑运算符来进行定位元素。</p><p>你可以尝试做做下面的这些题目</p><ol><li><p><code>//select/*[@value=1 or @value=2]</code></p><p>请问会有多少个元素被选中呢？</p><ul><li><input disabled="" type="checkbox"> A、1个</li><li><input checked="" disabled="" type="checkbox"> B、2个</li><li><input disabled="" type="checkbox"> C、不确定</li></ul></li><li><p><code>//select/*[@value and  @value!=2]</code></p><p>这样呢？</p><ul><li><input disabled="" type="checkbox"> A、0个</li><li><input disabled="" type="checkbox"> B、1个</li><li><input checked="" disabled="" type="checkbox"> C、7个</li><li><input disabled="" type="checkbox"> D、不确定</li></ul></li></ol><h5 id="6-任意属性值的匹配"><a href="#6-任意属性值的匹配" class="headerlink" title="6. 任意属性值的匹配"></a>6. 任意属性值的匹配</h5><p>如果你只想要匹配值为3的元素，而不关心其的属性名。那你可以</p><div class="code-wrapper"><pre><code class="hljs 1c"><span class="hljs-comment">//select/*[@*=3]</span></code></pre></div><p>在这里，我们用一个通配符来匹配其属性名，这样我们可以只关心其<strong>属性值</strong>。</p><h5 id="7-使用文本内容匹配"><a href="#7-使用文本内容匹配" class="headerlink" title="7. 使用文本内容匹配"></a>7. 使用文本内容匹配</h5><p>这里有一个新的函数，<code>text()</code> 可以用其来匹配所有文本。</p><p>例如我想要匹配到 <code>&lt;option value=&quot;7&quot;&gt;HTML&lt;/option&gt;</code> 这个元素，那么我就可以。</p><div class="code-wrapper"><pre><code class="hljs html">//option[text()=&#x27;HTML&#x27;]</code></pre></div><p>这里我换了一种写法，使用 <code>option</code> 去定位子元素。</p><p>这是全部匹配，那我只想匹配所有以P开头的编程语言元素呢？</p><div class="code-wrapper"><pre><code class="hljs html">//option[contains(text(),&#x27;P&#x27;)]</code></pre></div><p>真的是这样么？还是</p><div class="code-wrapper"><pre><code class="hljs html">//option[starts-with(text(),&#x27;P&#x27;)]</code></pre></div><p>还是像上面那样呢？正确答案是第二个 ✅。</p><p>我们要匹配的是以P开头的元素。那既然如此肯定也有 <code>ends-with</code> 啦，没错，这个真的有。</p><p>那就不做示例了。</p><p>同理，也可以匹配某个属性值的任意值。</p><div class="code-wrapper"><pre><code class="hljs html">//标签名[contains（@属性名，部分属性值）]//标签名[starts-with（@属性名，部分属性值）]//标签名[ends-with（@属性名，部分属性值）]a.starts-with      例子： //input[starts-with(@id,&#x27;ctrl&#x27;)]      解析：匹配以 ctrl开始的属性值b.ends-with        例子：//input[ends-with(@id,&#x27;_userName&#x27;)]    解析：匹配以 userName 结尾的属性值c.contains()       例子：//input[contains(@id,&#x27;userName&#x27;)]      解析：匹配含有 userName 属性值</code></pre></div><h5 id="8-轴定位表达式（一般不用）"><a href="#8-轴定位表达式（一般不用）" class="headerlink" title="8. 轴定位表达式（一般不用）"></a>8. 轴定位表达式（一般不用）</h5><div class="code-wrapper"><pre><code class="hljs html">* ancestor：祖先节点，包括父节点* parent：父节点* child：子节点* descendant：所有后代（儿子、孙子、曾孙子...）* preceding：当前元素节点标签之前的所有节点（HTML页面之前的）* preceding-sibling：当前元素节点标签之前的所有兄弟节点（同级）* following：当前元素节点标签之后的所有节点* following-sibling：当前元素节点标签之后的所有兄弟节点（同级）* 使用语法：轴名称::节点名称前后的定位与之前一致，用/隔开即可</code></pre></div><h3 id="XPATH定位验证"><a href="#XPATH定位验证" class="headerlink" title="XPATH定位验证"></a>XPATH定位验证</h3><ol><li>使用Google下的 <code>Elements</code> 选项卡内的，搜索（ <code>Ctrl + F</code> ）功能。</li><li>使用Google下的 <code>Console</code> 选项卡内的，<code>$x(“your_xpath_selector”)</code> 这样去搜索。</li></ol>]]></content>
    
    
    <categories>
      
      <category>软测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象（OOP）理解</title>
    <link href="/post/16661/"/>
    <url>/post/16661/</url>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>通过类来产生对象，<strong>类是对象的模板，对象是类的实现</strong>。类包括属性和方法（getter和setter）以及<strong>构造器（constructor）</strong>。</li><li>类可以被继承，子类可以有父类的所有属性或方法（公有的）。</li><li>抽象类（可以有抽象方法，也可以没有）被继承的时候，如果方法是抽象的，其继承类必须将其实现。只有方法才能被抽象，属性无法被抽象。抽象类只有方法签名（方法签名是指 <strong>类型和方法名以及参数</strong>，如果类型和方法名以及参数完全相同，那么则说明这两个方法相同）</li><li><strong>接口是一种特殊的抽象类</strong>（完全都是抽象方法和抽象类），接口是被实现（implements）的，被implement的时候需要，实现所有的方法。<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* Ability */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Ability</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jump</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* 实现了Ability的类 */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animals</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ability</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String color)</span> &#123;        <span class="hljs-built_in">super</span>(name, age, color);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jump</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;    &#125;&#125;</code></pre></div></li></ol><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>利用抽象数据类型将<strong>数据和基于数据的操作封装</strong>在一起，使其构成一个不可分割的独立实体（也就是常说的类）。<strong>数据被保护在抽象数据类型的内部</strong>，尽可能地隐藏内部的细节，<strong>只保留一些对外接口使之与外部发生联系</strong>。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。<br>在一个类中，只会有属性和方法。例如</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-comment">// public 和 private 是访问修饰符</span>    <span class="hljs-comment">// public 表示任何类都可以访问（公有）</span>    <span class="hljs-comment">// private 表示只有本类（自己）可以访问（私有）</span>    <span class="hljs-comment">// 下面都是属性（私有）</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> gender;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;    <span class="hljs-comment">// *对外接口，方法</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-comment">// *对外接口，方法</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getGender</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> gender == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;man&quot;</span> : <span class="hljs-string">&quot;woman&quot;</span>;    &#125;    <span class="hljs-comment">// *对外接口，方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="hljs-number">50</span>) &#123;            System.out.println(name + <span class="hljs-string">&quot; is working very hard!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(name + <span class="hljs-string">&quot; can&#x27;t work any more!&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>在上面的代码中，简单的定义了三个属性(私有)，在外界无法通过<code>.</code>的方式来访问，于是写（封装）了三个public接口，让外界可以通过这个接口来对对象属性进行操作。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>可以实现继承，子类对象必须能够替换掉所有的父类对象。<br>例如Cat和Animal就有从属关系，Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();</code></pre></div><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态分为编译时多态和运行时多态:</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定<br>运行时多态有三个条件:</li><li>继承</li><li>覆盖(重写)</li><li>向上转型<br>下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Instrument</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Instrument is playing...&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Instrument</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Wind is playing...&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Percussion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Instrument</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Percussion is playing...&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Music</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        List&lt;Instrument&gt; instruments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        instruments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wind</span>());        instruments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Percussion</span>());        <span class="hljs-keyword">for</span>(Instrument instrument : instruments) &#123;            instrument.play();        &#125;    &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用命令及解析</title>
    <link href="/post/38269/"/>
    <url>/post/38269/</url>
    
    <content type="html"><![CDATA[<h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p><code>lsof</code> 是一个常用的命令行工具，用于列出系统中打开的文件和网络连接。它的名字是 “list open files” 的缩写。<code>lsof</code> 常见的使用方法包括：</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>lsof</code></td><td>列出所有打开的文件和网络连接</td></tr><tr><td><code>lsof -p &lt;PID&gt;</code></td><td>列出指定进程打开的文件和网络连接</td></tr><tr><td><code>lsof -u &lt;username&gt;</code></td><td>列出指定用户打开的文件和网络连接</td></tr><tr><td><code>lsof i :&lt;port&gt;</code></td><td>查找正在使用某个端口的进程</td></tr><tr><td><code>lsof -i[TCP/UDP]</code></td><td>查看所有TCP&#x2F;UDP连接</td></tr></tbody></table><p>这些只是 <code>lsof</code> 命令的一些常见用法。你可以通过 <code>man lsof</code> 命令查看完整的用法和选项列表。</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>ps</code>是用于显示系统中当前正在运行的进程信息。可以显示各种信息，如进程的PID（进程标识符）、PPID（父进程标识符）、CPU使用情况、内存使用情况。</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>ps</code></td><td>显示当前用户的所有进程</td></tr><tr><td><code>ps -ef</code></td><td>显示所有进程的详细信息，会配合grep进行搜索</td></tr><tr><td><code>ps -u &lt;username&gt;</code></td><td>显示指定用户的所有进程</td></tr><tr><td><code>ps -p PID</code></td><td>显示指定进程的详细信息</td></tr><tr><td><code>ps -ejH</code></td><td>显示所有进程的树状结构</td></tr><tr><td><code>ps -ejf</code></td><td><strong>显示所有进程的树状结构和命令行参数。</strong></td></tr></tbody></table><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>这是一个常用的命令，用于在后台运行命令，即使终端关闭或者用户退出登录，命令仍然会继续执行。通常，<code>nohup</code>都会将命令的输出重定向到一个名为<code>nohup.out</code>的文件中，以防止输出被终端关闭。</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>nohup command &amp;</code></td><td><code>command</code>命令以后台进程的方式运行，同时将输出重定向 <code>nohup.out</code>。</td></tr><tr><td><code>nohup command &gt; output.log &amp;</code></td><td>指定输出重定向的文件中。</td></tr><tr><td><code>nohup command &gt; /dev/null &amp;</code></td><td>禁止输出重定向。</td></tr><tr><td><code>nohup command &gt; output.log 2&gt;&amp;1 &amp;</code></td><td>后台运行并禁止终端退出信号。</td></tr></tbody></table><p>在 Unix 和类 Unix 系统中，<code>&amp;</code> 符号用于将命令放入后台执行。当你在终端中运行一个命令时，如果在命令末尾加上 <code>&amp;</code> 符号，那么该命令就会在后台运行，而不会阻塞当前终端。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析VO、DTO、DO、PO的概念和区别</title>
    <link href="/post/42683/"/>
    <url>/post/42683/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析VO、DTO、DO、PO的概念和区别"><a href="#浅析VO、DTO、DO、PO的概念和区别" class="headerlink" title="浅析VO、DTO、DO、PO的概念和区别"></a>浅析VO、DTO、DO、PO的概念和区别</h1><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><ul><li>VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面或者组件的数据进行封装。</li><li>DTO（Data Transfer Object）：数据传输对象，泛指用于展示层（View）和服务层（Service）之间的数据传输对象。</li><li>DO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</li><li>PO（Persistent Object）： 持久化对象，和持久层的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中每个字段（或若干个）就对应PO的一个（或若干个）属性。</li></ul><h4 id="VO和DTO的区别"><a href="#VO和DTO的区别" class="headerlink" title="VO和DTO的区别"></a>VO和DTO的区别</h4><p>在绝大部分应用场景中，<strong>DTO和VO的属性值基本上一致，而且通常都是POJO</strong>，因此没有必要多次一举，但是这是在实现层面的思维，在对于设计层面上来说，概念上还是应该存在VO和DTO，因为这两者之间有着本质区别，DTO代表服务层需要接受的数据和返回的数据，而VO代表展示层需要显示的数据。</p><p>例如服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，<strong>对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定</strong>。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？</p><p>对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同。</p><p>回到设计层面上进行分析，<strong>从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，返回的DTO，不应该出现和表现形式的耦合。</strong></p><h4 id="DTO和DO的区别"><a href="#DTO和DO的区别" class="headerlink" title="DTO和DO的区别"></a>DTO和DO的区别</h4><p>首先是概念上的区别，<strong>DTO是展示层和服务层之间的数据传输对象</strong>（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如<strong>UserInfo（DO，领域对象)和User(DTO，数据传输对象)<strong>，对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。而在领域驱动设计中，</strong>DO不是简单的POJO，它具有领域业务逻辑</strong>。</p><h4 id="DTO和DO的应用"><a href="#DTO和DO的应用" class="headerlink" title="DTO和DO的应用"></a>DTO和DO的应用</h4><p>既然getUser方法返回的UserInfo不应该包含password，那么就不应该存在password这个属性定义，但如果同时有一个createUser的方法，传入的UserInfo需要包含用户的password，怎么办？（会导致需要创建的“O”比较多）</p><p>在设计层面，展示层向服务层传递的DTO与服务层返回给展示层的DTO在概念上是不同的，但是在实现层面，很少会这样做。我们可以设计一个<strong>完全兼容</strong>的DTO，在服务层接收数据的时候，<strong>不该由展示层设置的属性（如订单的总价应该由其单价、数量、折扣等决定），无论展示层是否设置，服务层都一概忽略</strong>，而在服务层返回数据时，不该返回的数据（如用户密码），就不设置对应的属性。</p><h4 id="DO和PO的区别"><a href="#DO和PO的区别" class="headerlink" title="DO和PO的区别"></a>DO和PO的区别</h4><p><strong>DO（领域对象）和PO（持久化对象）在绝大部分情况下是一一对应的，PO是只含有get&#x2F;set方法的POJO</strong>。</p><h4 id="DO和PO的应用"><a href="#DO和PO的应用" class="headerlink" title="DO和PO的应用"></a>DO和PO的应用</h4><p>由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过JPA，Hibernate Annotations&#x2F;hbm隐藏在DO之中。虽然如此，但有些问题我们还必须注意。</p><ul><li>对于DO中不需要持久化的属性，需要通过ORM显式声明，如，在JPA中，可以利用@Transient声明。</li><li>对于PO中为了某种持久化策略而存在的属性，例如version，由于DO、PO合并了，必须在DO中声明，但由于这个属性对DO是没有任何业务意义的，需要让该属性对外隐藏起来，最常见的做法是把该属性的get&#x2F;set方法私有化，甚至不提供get&#x2F;set方法，但对于Hibernate来说，这需要特别注意，由于Hibernate从数据库读取数据转换为DO时，是利用反射机制先调用DO的空参数构造函数构造DO实例，然后再利用JavaBean的规范反射出set方法来为每个属性设值，如果不显式声明set方法，或把set方法设置为private，都会导致Hibernate无法初始化DO，从而出现运行时异常，可行的做法是把属性的set方法设置为protected。</li><li>对于一个DO对应多个PO，或者一个PO对应多个DO的场景，以及属性级别的延迟加载，Hibernate都提供了很好的支持</li></ul><p><strong>分析设计层面和实现层面完全是两个独立的层面，即使实现层面通过某种技术手段可以将两个完全独立的概念合二为一，在分析设计层面，我们还是应该吧概念上独立的东西清晰的区分开来，这样对做好分析设计非常重要。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>好文摘录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动化测试常见问题</title>
    <link href="/post/38699/"/>
    <url>/post/38699/</url>
    
    <content type="html"><![CDATA[<h3 id="元素定位方式"><a href="#元素定位方式" class="headerlink" title="元素定位方式"></a>元素定位方式</h3><ol><li>ID定位</li><li>NAME定位</li><li>CLASS_NAME定位</li><li>TAG_NAME定位</li><li>LINK_TEXT定位</li><li>PARTIAL_LINK_TEXT定位</li><li>XPATH定位</li><li>CSS_SELECTOR定位</li></ol><h3 id="元素定位不到"><a href="#元素定位不到" class="headerlink" title="元素定位不到"></a>元素定位不到</h3><h5 id="1-元素定位方式结果不唯一，可能找到其他元素"><a href="#1-元素定位方式结果不唯一，可能找到其他元素" class="headerlink" title="1. 元素定位方式结果不唯一，可能找到其他元素"></a>1. 元素定位方式结果不唯一，可能找到其他元素</h5><p>首先是尝试更换元素的定位方式，优先使用ID或者XPATH等方式去定位，这样可以解决该问题。</p><h5 id="2-元素不可见，无法定位"><a href="#2-元素不可见，无法定位" class="headerlink" title="2. 元素不可见，无法定位"></a>2. 元素不可见，无法定位</h5><p>首先因为元素不可见，无法对其定位，所以也没办法使用Selenium对其进行操作，因为根本返回不到元素。在这种情况下，可以考虑使用配合js语句，使用Selenium执行JavaScript语句对元素的属性值进行删除。示例如下</p><div class="code-wrapper"><pre><code class="hljs python">js_script = <span class="hljs-string">&quot;arguments[0].removeAttribute(\&quot;target\&quot;)&quot;</span>  elem = self.driver.find_elements(By.TAG_NAME, <span class="hljs-string">&quot;button&quot;</span>)[<span class="hljs-number">4</span>].find_element(By.PARTIAL_LINK_TEXT, <span class="hljs-string">&quot;查看&quot;</span>)  self.driver.execute_script(js_script, elem)</code></pre></div><h5 id="3-XPATH方式定位错误"><a href="#3-XPATH方式定位错误" class="headerlink" title="3. XPATH方式定位错误"></a>3. XPATH方式定位错误</h5><p>当使用XPATH方式定位的时候，需要检查当前浏览器和测试环境浏览器打开的页面是否一致，如果不一致，可能会存在XPATH方式定位不到的情况。<br>解决方案：<strong>将sleep时间设置的长一点，然后从Selenium打开的浏览器中去获取XPATH定位</strong>，这样获取到的XPATH正确率很高。</p><h3 id="PO模式下的代码提示问题？"><a href="#PO模式下的代码提示问题？" class="headerlink" title="PO模式下的代码提示问题？"></a>PO模式下的代码提示问题？</h3><p>因为PO需要我们对Selenium的原生操作进行封装，例如封装页面操作find_element和open操作，但是在BasePage下编写代码的时候，是没有代码提示的。原因是因为，Python是弱类型语言，IDE（Pycharm）不知道实际的对象类型。因此就要在代码指定变量的类型。<br>示例如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, driver</span>):        self.driver: webdriver.Chrome = driver        self.base_url = <span class="hljs-string">&quot;http://172.20.4.250/ams&quot;</span>        self.timeout = <span class="hljs-number">10</span></code></pre></div><p>但是不要忘记导包，这样其类型就被指定，然后就可以使用代码提示了。<br><strong>代码编写完，记得删掉: webdriver.Chrome，因为比赛的裁判可能只认正确答案，这样可能被判错。</strong></p><h3 id="find-elements的下标确定方式"><a href="#find-elements的下标确定方式" class="headerlink" title="find_elements的下标确定方式"></a>find_elements的下标确定方式</h3><p>例题：使用By.TAG_NAME的方式定位button，让你定位页面的“新增”按钮。<br>那怎么知道“新增”按钮的下标呢？在“检查”中<code>Ctrl+F</code>使用XPATH方式查找，例如<code>//button</code><br>则会查找整个页面所有的button按钮，并且会在页面中高亮显示。</p><img src="/post/38699/find_success.png" class=""><p><strong>但是不要忘记-1，因为下标是从1开始计数的。</strong></p>]]></content>
    
    
    <categories>
      
      <category>软测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动化测试PO测试模式</title>
    <link href="/post/17797/"/>
    <url>/post/17797/</url>
    
    <content type="html"><![CDATA[<h3 id="PO测试模式"><a href="#PO测试模式" class="headerlink" title="PO测试模式"></a>PO测试模式</h3><p>Page Object Model（页面对象模型）是一种<strong>分层设计</strong>模式，核心是通过页面层封装所有的页面元素以及操作。<br>对于2022年国赛题，首先将页面基本操作全部封装在BasePage中。然后再设置各个页面继承自BasePage，其中包括各个元素和操作，并定义测试方法。<br>首先看一下当前目录，Page页面封装着具体页面的操作，test页面封装了测试用例。</p><img src="/post/17797/path.png" class=""><h4 id="BasePage-py"><a href="#BasePage-py" class="headerlink" title="BasePage.py"></a>BasePage.py</h4><p>首先是因为Python是弱类型语言，IDE不知道实际的对象类型。因此就要在代码指定变量的类型。<br>通过使用<code>:</code>来指定类型，webdriver.Chrome<br>有如下步骤</p><ol><li>首先通过<code>__init__</code>来初始化页面基本信息，例如base_url等。</li><li>定义一个<code>find_Element</code>函数，其中需要对其进行解包。</li></ol><h6 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h6><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">class</span> <span class="hljs-title class_">Page</span>:    <span class="hljs-comment"># 指定类型</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, driver: webdriver.Chrome</span>):        self.driver: webdriver.Chrome = driver        self.base_url = <span class="hljs-string">&quot;http://172.20.4.250/ams&quot;</span>        self.timeout = <span class="hljs-number">10</span>    <span class="hljs-comment"># 私有函数</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_open</span>(<span class="hljs-params">self, url</span>):        <span class="hljs-comment"># url拼接</span>        <span class="hljs-comment"># url这个参数相当于资源地址</span>        url_ = self.base_url + url        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test page is %s&#x27;</span>, url_)        self.driver.maximize_window()        self.driver.implicitly_wait(self.timeout)        self.driver.get(url_)        sleep(<span class="hljs-number">1</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self, url</span>):        <span class="hljs-comment"># 暴露的open函数</span>        self._<span class="hljs-built_in">open</span>(url)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_Element</span>(<span class="hljs-params">self, *loc</span>):        <span class="hljs-comment"># 解包</span>        <span class="hljs-keyword">return</span> self.driver.find_element(*loc)</code></pre></div><h4 id="对于页面的封装（具体）"><a href="#对于页面的封装（具体）" class="headerlink" title="对于页面的封装（具体）"></a>对于页面的封装（具体）</h4><p>首先需要导入BasePage，需要将其添加到环境变量中。<br>因此需要如下代码，<strong>不然会找不到BasePage</strong>。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> ospath = os.path.abspath(os.path.join(os.getcwd(), <span class="hljs-string">&quot;..&quot;</span>)) + <span class="hljs-string">&quot;/Page&quot;</span>sys.path.append(path)</code></pre></div><p>因为是在test文件夹内运行，因此运行目录是test目录下，这也就导致在LoginPage中无法找到BasePage。<br>所以首先需要<code>os.path.join(os.getcwd(), &quot;..&quot;)</code>得到test的上一级目录，也就是PoTest目录下，然后得到其绝对路径，然后将Page目录拼接上去。<br>最后将这个路径添加到sys.path中去。</p><p>然后就是定义一个具体”页面”，让其继承自BasePage.Page，定义页面的相关操作。最后写一个测试方法，传入页面相关操作的参数。</p><h6 id="LoginPage-py"><a href="#LoginPage-py" class="headerlink" title="LoginPage.py"></a>LoginPage.py</h6><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os.path<span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> sys<span class="hljs-comment"># os.getcwd() 当前运行文件的目录</span>path = os.path.abspath(os.path.join(os.getcwd(), <span class="hljs-string">&quot;..&quot;</span>)) + <span class="hljs-string">&quot;/Page&quot;</span>sys.path.append(path)<span class="hljs-keyword">import</span> BasePage<span class="hljs-keyword">class</span> <span class="hljs-title class_">loginPage</span>(BasePage.Page):    taskId_loc = (By.ID, <span class="hljs-string">&quot;taskId&quot;</span>)    username_loc = (By.NAME, <span class="hljs-string">&quot;loginName&quot;</span>)    password_loc = (By.NAME, <span class="hljs-string">&quot;password&quot;</span>)    submit_loc = (By.TAG_NAME, <span class="hljs-string">&quot;button&quot;</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">type_username</span>(<span class="hljs-params">self, username</span>):        self.find_Element(*self.username_loc).clear()        self.find_Element(*self.username_loc).send_keys(username)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">type_password</span>(<span class="hljs-params">self, password</span>):        self.find_Element(*self.password_loc).clear()        self.find_Element(*self.password_loc).send_keys(password)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">type_submit</span>(<span class="hljs-params">self</span>):        self.find_Element(*self.submit_loc).click()    <span class="hljs-keyword">def</span> <span class="hljs-title function_">type_taskid</span>(<span class="hljs-params">self, ids</span>):        self.find_Element(*self.taskId_loc).clear()        self.find_Element(*self.taskId_loc).send_keys(ids)<span class="hljs-keyword">def</span> <span class="hljs-title function_">test_user_login</span>(<span class="hljs-params">driver, username, password, ids</span>):    login_page = loginPage(driver)    <span class="hljs-comment"># 调用的是BasePage里的open方法</span>    login_page.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/front/login.do&quot;</span>)    login_page.type_username(username)    login_page.type_password(password)    login_page.type_taskid(ids)    time.sleep(<span class="hljs-number">3</span>)    login_page.type_submit()</code></pre></div><h6 id="AddPage-py"><a href="#AddPage-py" class="headerlink" title="AddPage.py"></a>AddPage.py</h6><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> PoTest.Page.BasePage <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<span class="hljs-keyword">class</span> <span class="hljs-title class_">AddC</span>(<span class="hljs-title class_ inherited__">Page</span>):    bumen_loc = (By.LINK_TEXT, <span class="hljs-string">&quot;部门管理&quot;</span>)    add_loc = (By.XPATH, <span class="hljs-string">&#x27;/html/body/div[2]/div[2]/div/div[2]/div/div[1]/button&#x27;</span>)    name_loc = (By.ID, <span class="hljs-string">&quot;title&quot;</span>)    bianma_loc = (By.ID, <span class="hljs-string">&quot;code&quot;</span>)    baocun_loc = (By.XPATH, <span class="hljs-string">&#x27;/html/body/div[4]/div[1]/div[2]/div[2]/div[1]/div/div[3]/button[1]&#x27;</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">type_bumen</span>(<span class="hljs-params">self</span>):        self.find_Element(*self.bumen_loc).click()    <span class="hljs-keyword">def</span> <span class="hljs-title function_">type_add</span>(<span class="hljs-params">self</span>):        self.find_Element(*self.add_loc).click()    <span class="hljs-keyword">def</span> <span class="hljs-title function_">type_name</span>(<span class="hljs-params">self, name</span>):        self.find_Element(*self.name_loc).clear()        self.find_Element(*self.name_loc).send_keys(name)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">type_bianma</span>(<span class="hljs-params">self, bianma</span>):        self.find_Element(*self.bianma_loc).clear()        self.find_Element(*self.bianma_loc).send_keys(bianma)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">type_baocun</span>(<span class="hljs-params">self</span>):        self.find_Element(*self.baocun_loc).click()<span class="hljs-keyword">def</span> <span class="hljs-title function_">test_user_add</span>(<span class="hljs-params">driver, Name, Bianma</span>):    add_page = AddC(driver)    add_page.type_bumen()    add_page.type_add()    time.sleep(<span class="hljs-number">1</span>)    add_page.type_name(Name)    add_page.type_bianma(Bianma)    add_page.type_baocun()</code></pre></div><h4 id="test目录下的测试方法"><a href="#test目录下的测试方法" class="headerlink" title="test目录下的测试方法"></a>test目录下的测试方法</h4><p>在这里将对应页面的操作组合起来。</p><h6 id="test-Add-py"><a href="#test-Add-py" class="headerlink" title="test_Add.py"></a>test_Add.py</h6><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> PoTest.Page.LoginPage <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> PoTest.Page.AddPage <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleepdriver = webdriver.Chrome()test_user_login(driver, <span class="hljs-string">&quot;223030246&quot;</span>, <span class="hljs-string">&quot;223030246&quot;</span>, <span class="hljs-string">&quot;39&quot;</span>)sleep(<span class="hljs-number">3</span>)test_user_add(driver, <span class="hljs-string">&quot;测试数据&quot;</span>, <span class="hljs-string">&quot;BM00032&quot;</span>)sleep(<span class="hljs-number">3</span>)driver.quit()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category> Python教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单元测试笔记</title>
    <link href="/post/44266/"/>
    <url>/post/44266/</url>
    
    <content type="html"><![CDATA[<h1 id="单元测试-T1"><a href="#单元测试-T1" class="headerlink" title="单元测试 T1"></a>单元测试 T1</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目 1"></a>题目 1</h2><p>根据下列流程图编写程序实现相应分析处理并显示结果。返回文字 “x&#x3D;a*a*b 的值:”和 x 的值;返回文字“x&#x3D;a-b 的值:”和 x 的值;返回文字“x&#x3D;a+b 的值:”和 x 的值。其中变量 a、b 均须为整型。编写程序代码，使用 JUnit 框架 编写测试类对编写的程序代码进行测试，测试类中设计最少的测试数据满足语句覆盖测试，每条测试数据需要在测试类中编写一个测试方法。使用** startsWith** 判断期望结果返回文字和实际返回文字是否一致。</p><img src="/post/44266/a.png" class=""><p>源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> source;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">q1</span> &#123;<span class="hljs-type">int</span> x;<span class="hljs-keyword">public</span> String <span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">9</span> &amp;&amp; b &gt; <span class="hljs-number">5</span>) &#123;x = a * a * b;<span class="hljs-comment">// a &gt; 9 &amp;&amp; b &gt; 5的情况</span><span class="hljs-keyword">return</span> x + <span class="hljs-string">&quot;=a*a*b&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> &amp;&amp; b &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// a &lt; 0 &amp;&amp; b &lt; 0的情况</span>x = a - b;<span class="hljs-keyword">return</span> x + <span class="hljs-string">&quot;=a-b&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 不满足的情况</span>x = a + b;<span class="hljs-keyword">return</span> x + <span class="hljs-string">&quot;=a+b&quot;</span>;&#125;&#125;&#125;&#125;</code></pre></div><p>根据题目的流程图完成即可。<br>最终测试用例如下。</p><img src="/post/44266/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95T1-20240112213311680.png" class=""><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目 2"></a>题目 2</h2><p>根据输入的年份和月份判断月份的天数。若月份不在有效范围之内， 应提示:“&#x3D;&#x3D;月份输入不正确。&#x3D;&#x3D;”。月份不为 2 月，根据输入月份输出对应的月份天数。月份为 2 月，根据年份判断如为&#x3D;&#x3D;普通闰年&#x3D;&#x3D;，输出 2 月份正确天数;如为&#x3D;&#x3D;世纪闰年&#x3D;&#x3D;，输出 2 月份正确天数;不为闰年输出 2 月份天数。返回结果格式:“year 年 month 月份的天数是 days 天。”year、month 为传入的值，days 为判断得到的 天数值。其中变量 year、month 均须为正整数。编写程序代码，使用 JUnit 框架编写测试类对编写的程序代码进行测试，测试类中设计最少的测试数据满足语句 覆盖测试，每条测试数据需要在测试类中编写一个测试方法。使用 assertThat 中 equalTo 断言判断返回期望结果和实际返回是否一致。<br><br>首先我们来明确一下概念，闰年的 2 月为 29 天，根据题意，我们分析得出，闰年分为以下两种。</p><ul><li>年份能被 4 整除且不能被 100 整除，则是普通闰年。</li><li>年份能被 100 整除且能被 400 整除，则是世纪闰年。<br>  其他月份 1、3、5、7、8、10、12 都为 31 天。即可得出源代码如下。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> source;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">q2</span> &#123;<span class="hljs-keyword">public</span> String <span class="hljs-title function_">back</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month)</span> &#123;<span class="hljs-type">int</span> days;<span class="hljs-keyword">if</span> (month &lt;= <span class="hljs-number">12</span> &amp;&amp; month &gt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (month == <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">// 处理月份为2月的日期</span><span class="hljs-keyword">if</span> (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 普通闰年</span>days = <span class="hljs-number">29</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (year % <span class="hljs-number">100</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 世纪闰年</span>days = <span class="hljs-number">29</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 非闰年</span>days = <span class="hljs-number">28</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (month == <span class="hljs-number">4</span> || month == <span class="hljs-number">6</span> || month == <span class="hljs-number">10</span> || month == <span class="hljs-number">11</span>) &#123;days = <span class="hljs-number">30</span>;&#125; <span class="hljs-keyword">else</span> &#123;days = <span class="hljs-number">31</span>;&#125;&#125;<span class="hljs-keyword">return</span> year + <span class="hljs-string">&quot; 年 &quot;</span> + month + <span class="hljs-string">&quot; 月份的天数是 &quot;</span> + days + <span class="hljs-string">&quot; 天。&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;月份输入不正确。&quot;</span>;&#125;&#125;&#125;</code></pre></div><p>单元测试尽量保证条件逻辑清晰，不要出现遗漏。<br>最后测试用例如下</p><img src="/post/44266/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95T1-20240112224617189.png" class=""><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目 3"></a>题目 3</h2><p>邮箱注册需要填写邮箱地址和密码。其中要求&#x3D;&#x3D;邮箱格式“登录名@主机名.域名”，登录名为 5 个字母，主机名固定为下面 2 个 163、126，域名为 com 或 com.cn。密码为 6 个(含 6)以上数字组成&#x3D;&#x3D;。填写正确则提示“信息正确”， 否则根据实际情况提示“**不符合要求”(**为邮箱地址或密码)。编写程序代码，使用 JUnit 框架编写测试类对编写的程序代码进行测试，测试类中设计最少 的测试数据满足语句覆盖测试，每条测试数据需要在测试类中编写一个测试方 法。使用 assertThat 中 equalTo 断言判断输出文字期望结果值和实际返回值是否一致。<br><br>首先，看到这道题就想到了正则表达式，所以先去复习了一下 Java 的正则表达式语法。在 Java 中使用正则表达式主要使用了</p><ul><li><code>java.util.regex.Matcher</code></li><li><code>java.util.regex.Pattern</code><br>  以上两个工具包。<br>  [[正则表达式]]<br>  然后就是如何写这个正则表达式的问题了。首先就是<strong>邮箱的匹配</strong>，分析有如下条件</li></ul><ol><li>格式为：登录名@主机名.域名</li><li>登录名为 5 个字母</li><li>主机名为 163 或者 126</li><li>域名为 com 或者 com.cn<br>首先登录名，<code>[a-zA-Z]</code>通过这种方式来匹配字母，然后是 5 个的数量限定。只需要在后面<code>&#123;5&#125;</code>即可完成对数量的限定。<br>接下来，就是一个@<br>然后是主机名，在正则表达式中，可以使用<code>｜</code>来表示“或”，所以<code>163|126</code>但是需要加上<code>()</code>表示一组<br>接下来的域名，也差不多道理<code>(com|com.cn)</code><br>所以可以得出整个正则表达式如下<br><code>[a-zA-Z]@(126|163).(com|com.cn)</code><br><font color="#d99694">但是在这种情况下，还有很多元字符没有被转义</font> 最后如下</li></ol><div class="code-wrapper"><pre><code class="hljs regex">[a-zA-Z]@(126|163)\.(com|com\.cn)$</code></pre></div><p>接下来是密码的匹配，密码的要求只要 6&#x3D;+个字符组成即可<br>所以正则表达式如下</p><div class="code-wrapper"><pre><code class="hljs regex">\d&#123;6,&#125;$</code></pre></div><p><code>\d</code>的含义代表阿拉伯数字字符。<br><br>解决了正则表达式的书写问题，接下来就是匹配了。</p><ol><li>通过 Pattern 类内的静态方法 compile 将字符串类型的正则表达式转为 Pattern 对象。</li><li>通过 Pattern 对象内的 matcher 来返回一个 Matcher 对象。</li><li>然后在调用 Matcher 对象内的 matches()方法来返回匹配是否成功。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> source;<span class="hljs-keyword">import</span> java.util.regex.Matcher;<span class="hljs-keyword">import</span> java.util.regex.Pattern;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">q3</span> &#123;<span class="hljs-keyword">public</span> String <span class="hljs-title function_">youxiang</span><span class="hljs-params">(String email, String password)</span> &#123;<span class="hljs-type">String</span> <span class="hljs-variable">email_regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^[a-zA-Z]&#123;5&#125;@(163|126)\\.(com\\.cn|com)$&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">password_regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\d&#123;6,&#125;$&quot;</span>;<span class="hljs-type">Pattern</span> <span class="hljs-variable">emailPattern</span> <span class="hljs-operator">=</span> Pattern.compile(email_regex);<span class="hljs-type">Pattern</span> <span class="hljs-variable">passwordPattern</span> <span class="hljs-operator">=</span> Pattern.compile(password_regex);<span class="hljs-type">Matcher</span> <span class="hljs-variable">emMatcher</span> <span class="hljs-operator">=</span> emailPattern.matcher(email);<span class="hljs-type">Matcher</span> <span class="hljs-variable">paMatcher</span> <span class="hljs-operator">=</span> passwordPattern.matcher(password);<span class="hljs-keyword">if</span> (paMatcher.matches() &amp;&amp; emMatcher.matches()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;信息正确&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (!emMatcher.matches()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;邮箱地址不符合要求&quot;</span>;&#125;<span class="hljs-keyword">if</span> (!paMatcher.matches()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;密码不符合要求&quot;</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;邮箱地址和密码均不符合要求&quot;</span>;&#125;&#125;&#125;</code></pre></div><p>然后需要注意的一个点是，在正则表达式字符串中，需要将<code>\</code>字符再次进行转义。<br>然后逻辑如上，如果邮箱地址和密码都正确，则输出”信息正确“，否则会根据条件进行判断，然后输出对应的结果。<br>测试代码如下</p><img src="/post/44266/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95T1-20240112234412259.png" class=""><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目 4"></a>题目 4</h2><p>根据下列流程图编写程序实现相应分析处理并显示结果。编写程序代码，使用 JUnit 框架编写测试类对编写的程序代码进行测试，测试类中设计最少的测试数据满足语句覆盖测试，测试类使用参数化测试(@Parameters)完成 测试。使用 assertEquals 判断输入数据测试方法期望结果值和实际返回值是否一致。<br><br>源代码如下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> source;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">q4</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">check</span><span class="hljs-params">(String username,String password)</span> &#123;<span class="hljs-keyword">if</span> (username == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; password == <span class="hljs-string">&quot;&quot;</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户名或密码不能为空&quot;</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (username.equals(<span class="hljs-string">&quot;admin&quot;</span>) &amp;&amp; password.equals(<span class="hljs-string">&quot;123&quot;</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录成功&quot;</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(!username.equals(<span class="hljs-string">&quot;admin&quot;</span>) &amp;&amp; password.equals(<span class="hljs-string">&quot;123&quot;</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请输入正确的用户名&quot;</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(username.equals(<span class="hljs-string">&quot;admin&quot;</span>) &amp;&amp; !password.equals(<span class="hljs-string">&quot;123&quot;</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请输入正确的密码&quot;</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (!username.equals(<span class="hljs-string">&quot;admin&quot;</span>) &amp;&amp; !password.equals(<span class="hljs-string">&quot;123&quot;</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请输入正确的用户名和密码&quot;</span>;&#125;&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;&#125;</code></pre></div><p>在本题中，需要使用参数化测试（@Parameters）来进行测试。<br>参数化测试需要数据，测试方法。<br></p><h4 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h4><p><strong>首先</strong>需要在测试类上加上@RunWith(Parameterized.class)该注解表明指定如下的运行器。<br><strong>然后</strong>就是在提供数据的方法上加上@Parameters 注解。（该方法必须为静态，返回一个 Collection）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Parameters</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collection <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[][] &#123;&#123; <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;登录成功&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;admi1n&quot;</span>, <span class="hljs-string">&quot;1233&quot;</span>, <span class="hljs-string">&quot;请输入正确的用户名和密码&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;admsin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;请输入正确的用户名&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>, <span class="hljs-string">&quot;请输入正确的密码&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;用户名或密码不能为空&quot;</span> &#125;&#125;);&#125;</code></pre></div><p>在此处，使用了 Arrays 类的 asList 静态方法，new 一个双层 Object[][]<br>里面保存了要测试的数据。</p><ul><li>第一个为用户名</li><li>第二个为密码</li><li>第三个为预期结果。<br>  接下来有两种注入方式创建测试。</li></ul><h5 id="A-构造器注入"><a href="#A-构造器注入" class="headerlink" title="A.构造器注入"></a>A.<u>构造器注入</u></h5><p>通过声明测试类的构造器，然后完成测试类内属性的初始化。<br>代码如下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> source;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.assertEquals;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.junit.runners.Parameterized;<span class="hljs-keyword">import</span> org.junit.runners.Parameterized.Parameter;<span class="hljs-keyword">import</span> org.junit.runners.Parameterized.Parameters;<span class="hljs-comment">// 类指定的运行器</span><span class="hljs-meta">@RunWith(Parameterized.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">q4_test</span> &#123;<span class="hljs-comment">// 提供数据的方法</span><span class="hljs-meta">@Parameters</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collection <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[][] &#123;&#123; <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;登录成功&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;admi1n&quot;</span>, <span class="hljs-string">&quot;1233&quot;</span>, <span class="hljs-string">&quot;请输入正确的用户名和密码&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;admsin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;请输入正确的用户名&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>, <span class="hljs-string">&quot;请输入正确的密码&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;用户名或密码不能为空&quot;</span> &#125;&#125;);&#125;<span class="hljs-comment">// 三个参数，分别对应admin 123 登录成功</span><span class="hljs-keyword">private</span> String usernameString;<span class="hljs-keyword">private</span> String passwordString;<span class="hljs-keyword">private</span> String expectString;    <span class="hljs-comment">// 构造器</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">q4_test</span><span class="hljs-params">(String username, String password, String expected)</span> &#123;<span class="hljs-built_in">this</span>.usernameString = username;<span class="hljs-built_in">this</span>.passwordString = password;<span class="hljs-built_in">this</span>.expectString = expected;&#125;<span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// 使用assertEquals进行断言</span>assertEquals(expectString, q4.check(usernameString, passwordString));&#125;&#125;</code></pre></div><h5 id="B-属性注入"><a href="#B-属性注入" class="headerlink" title="B.属性注入"></a>B.<u>属性注入</u></h5><p>属性注入指的是，将类的属性直接参数化。<br>在这里我们需要将类的属性声明为 public，然后在上面写上注解@Parameter(index)，其中 index 为在 data 中的索引。&#x3D;&#x3D;然后不能有构造器&#x3D;&#x3D;。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> source;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.assertEquals;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.junit.runners.Parameterized;<span class="hljs-keyword">import</span> org.junit.runners.Parameterized.Parameter;<span class="hljs-keyword">import</span> org.junit.runners.Parameterized.Parameters;<span class="hljs-comment">// 类指定的运行器</span><span class="hljs-meta">@RunWith(Parameterized.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">q4_test2</span> &#123;<span class="hljs-comment">// 提供数据的方法</span><span class="hljs-meta">@Parameters</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collection <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[][] &#123;&#123; <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;登录成功&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;admi1n&quot;</span>, <span class="hljs-string">&quot;1233&quot;</span>, <span class="hljs-string">&quot;请输入正确的用户名和密码&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;admsin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;请输入正确的用户名&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>, <span class="hljs-string">&quot;请输入正确的密码&quot;</span> &#125;,&#123; <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;用户名或密码不能为空&quot;</span> &#125;&#125;);&#125;<span class="hljs-meta">@Parameter</span><span class="hljs-keyword">public</span> String usernameString;<span class="hljs-meta">@Parameter(1)</span><span class="hljs-keyword">public</span> String passwordString;<span class="hljs-meta">@Parameter(2)</span><span class="hljs-keyword">public</span> String expectString;<span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// 使用assertEquals进行断言</span>assertEquals(expectString, q4.check(usernameString, passwordString));&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>软测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>功能测试背诵部分</title>
    <link href="/post/19621/"/>
    <url>/post/19621/</url>
    
    <content type="html"><![CDATA[<h2 id="A2-功能测试计划"><a href="#A2-功能测试计划" class="headerlink" title="A2-功能测试计划"></a>A2-功能测试计划</h2><h4 id="编写目的"><a href="#编写目的" class="headerlink" title="编写目的"></a>编写目的</h4><p>编写本测试计划的目的是为软件开发<strong>项目管理者，产品工程师，软件工程师，测试工程师</strong>提供关于资产管理项目系统整体功能测试的指导。同时该文档也是用户确定<strong>软件是否完整测试的重要依据。</strong></p><h4 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h4><p>随着信息化时代的到来，实现资产的数字化网络化管理，是任何一个事业单位及企业的需求:通过计算机软件，使资产易于维护、方便查询，提高资产管理的准确性，进而提高工作效率。<strong>（直接去需求管理说明书复制，粘贴）</strong></p><h4 id="测试目的"><a href="#测试目的" class="headerlink" title="测试目的"></a>测试目的</h4><p><strong>系统是否实现了经过各方确认的《BS资产管理系统修改规格说明书》约定的功能要求</strong>。系统经过功能测试，能够稳定运行，达到上线正式运行的各项要求。</p><h4 id="测试参考文档"><a href="#测试参考文档" class="headerlink" title="测试参考文档"></a>测试参考文档</h4><p>《BS资产管理系统需求说明书》</p><h4 id="测试范围"><a href="#测试范围" class="headerlink" title="测试范围"></a>测试范围</h4><p>测试主要根据《BS资产管理系统需求说明书》文档进行功能测试，包括功能测试，UI等。主要模块包括：<br>&emsp;&emsp;&emsp;<strong>超级管理员</strong>：登录、（首页）、个人信息、资产类别、品牌、取得方式、供应商、存放地点。<br>&emsp;&emsp;&emsp;<strong>资产管理员</strong>：登录、（首页）、个人信息、资产类别、品牌、取得方式、供应商、存放地点、部门管理、人员管理、资产入库、资产借还、资产转移、资产维修、资产报废、资产盘点、资产申购、统计报表。<br>&emsp;&emsp;&emsp;(看需求说明书)</p><h4 id="测试提交文档"><a href="#测试提交文档" class="headerlink" title="测试提交文档"></a>测试提交文档</h4><p>《测试计划》<br>《测试用例》<br>《测试Bug缺陷报告清单》<br>《测试总结报告》<br><strong>缺一不可</strong></p><h4 id="人力资源分配"><a href="#人力资源分配" class="headerlink" title="人力资源分配"></a>人力资源分配</h4><p>必须要同时包含“编写测试计划”，“编写测试总结”，“编写测试用例”，“功能测试”这四个描述。</p><h4 id="功能测试计划"><a href="#功能测试计划" class="headerlink" title="功能测试计划"></a>功能测试计划</h4><p>从EXCEL编写，<strong>至少80个</strong>，每个测试点都必须分配测试人员</p><h4 id="测试进度安排"><a href="#测试进度安排" class="headerlink" title="测试进度安排"></a>测试进度安排</h4><p>测试阶段：必须同时包含“<strong>需求分析”、“编写测试计划”、“编写测试用例”、“功能测试”、“测试总结报告</strong>”5项描述。<br>时间安排：时间安排为计划的具体时间段，开始时间、结束时间不得超出竞赛时间范围。<br>产出：必须同时包含“<strong>测试计划”、“测试用例”、“Bug缺陷报告清单”、“测试总结报告</strong>”4项描述。</p><h4 id="相关风险"><a href="#相关风险" class="headerlink" title="相关风险"></a>相关风险</h4><p>至少需要5条风险，并且要写出风险的应对措施。<br>风险：</p><ol><li>需求风险：测试环境是否搭建完成，测试资源是否提供。</li><li>测试用例风险：测试用例是否完整。</li><li>测试风险：测试任务分配是否合理，测试方案是否合理。</li><li>时间风险：有些测试项目大，耗时大，可能造成测试延期。</li><li>人员分析：所有测试人员是否到位，测试水平是否达标。</li></ol><p>解决计划：</p><ol><li>向项目组申请测试资源的到位，测试环境的搭建。</li><li>重新阅读需求说明书，划分功能模块，编写测试用例。</li><li>按照实际情况修改测试方案，分配测试人员任务。</li><li>倡导所有测试人员加入测试。</li><li>对参加测试的人员进行审核，培训。</li></ol><h2 id="A5-功能测试总结报告"><a href="#A5-功能测试总结报告" class="headerlink" title="A5-功能测试总结报告"></a>A5-功能测试总结报告</h2><h4 id="编写目的-1"><a href="#编写目的-1" class="headerlink" title="编写目的"></a>编写目的</h4><p>本测试报告文资产系统的测试报告，目的在于<strong>总结测试阶段的测试情况</strong>以及<strong>分析测试结果</strong>，描述系统是否符合用户需求，是否已经达到用户预期的功能目标，并对测试质量进行分析。测试报告参考文档提供给用户、<strong>测试人员、开发人员、产品人员、项目管理者</strong>、其他管理人员和需要阅读本报告的人员阅读。</p><h4 id="项目背景-1"><a href="#项目背景-1" class="headerlink" title="项目背景"></a>项目背景</h4><p>随着信息化时代的到来，实现资产的数字化网络化管理，是任何一个事业单位及企业的需求:通过计算机软件，使资产易于维护、方便查询，提高资产管理的准确性，进而提高工作效率。<strong>（直接去需求管理说明书复制，粘贴）</strong></p><h4 id="测试参考文档-1"><a href="#测试参考文档-1" class="headerlink" title="测试参考文档"></a>测试参考文档</h4><p>《BS资产管理系统需求说明书》<br>《测试计划》<br>《测试用例》<br>《测试Bug缺陷报告清单》</p><h4 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h4><p>测试用例的设计采用<strong>等价类划分法、边界值法、错误推测法、因果图法、场景法</strong>。</p><ol><li>等价类划分法：等价类划分法是将程序所有可能的输入数据，包括有效的和无效的划分为若干个等价类，然后从每个部分中选取具有代表性的测试用例进行合理分类，测试用例由有效等价类和无效等价类的代表组成，从而保证测试用例的完整性和代表性。</li><li>边界值分析法：边界是指相对于输入等价类和输出等价类而言，稍高于其边界值的一些特定情况。基于边界的方法是根据定义域来实现的，最终演变为边界值分析、健壮性测试、最坏情况、和健壮最坏情况测试四种技术。</li><li>错误推测法：错误推测法是指在测试程序时，人们可以根据经验或直接推测程序中可能存在的各种错误，从而有针对性的编写检查这些错误的测试用例。</li><li>因果图法：等价类划分法和边界值分析法都是着重考虑输入条件，如果程序输入之间没有什么联系，采用等价类划分法和边界值分析法时一种有效的方法，但是如果程序之间存在某种关系，需要考虑输入条件的各种组合，这就需要用到因果图法，能有效分析各种输入的组合情况。</li><li>场景法：通过运用场景来对系统的功能点或者业务流程描述，从而提高测试效果的方法。</li></ol><h4 id="软件测试方法"><a href="#软件测试方法" class="headerlink" title="软件测试方法"></a>软件测试方法</h4><ol><li>UI测试：用户界面测试是指测试用户界面的风格是否满足客户要求，文字是否正确，页面是否美观，文字，图片组合是否完美，操作是否友好等等。UI 测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏览功能。确保用户界面符合公司或行业的标准。包括用户友好性、人性化、易操作性测试。</li><li>黑盒测试：软件测试人员以用户的角度，通过各种输入和观察软件的各种输出结果来发现软件存在的缺陷，而不关心程序具体如何实现的一种软件测试方法。</li></ol><h4 id="测试进度"><a href="#测试进度" class="headerlink" title="测试进度"></a>测试进度</h4><h5 id="测试进度回顾"><a href="#测试进度回顾" class="headerlink" title="测试进度回顾"></a>测试进度回顾</h5><p> 所有模块用例都执行完毕。因为时间问题，有的用例并没有执行，是一个比较严重的问题，对用例的执行速度有待提高，如何快速并正确的执行全部用例是需要解决的重点。<strong>或按测试进度顺利执行了全部用例。</strong></p><table><thead><tr><th>测试阶段</th><th>实际时间安排</th><th>参与人员</th><th>实际工作</th></tr></thead><tbody><tr><td>需求分析</td><td>开始时间-</td><td></td><td>进行需求分析和理解</td></tr><tr><td>编写测试计划</td><td></td><td></td><td>编写测试计划文档</td></tr><tr><td>编写测试用例</td><td></td><td></td><td>设计和编写测试用例</td></tr><tr><td>功能测试</td><td></td><td></td><td>执行功能测试</td></tr><tr><td>测试总结报告</td><td>-结束时间</td><td></td><td>编写测试总结报告</td></tr></tbody></table><h4 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h4><p>测试结论（1分）：<br>1、 测试结果（0.25分）：必须包含“测试结果”描述，否则得0分<br>2、 问题总结（0.25分）：必须包含“问题总结”描述，否则得0分<br>3、 质量（0.25分）：必须包含“质量”描述，否则得0分<br>4、 收获（0.25分）：必须包含“收获”描述，否则得0分</p><p>收获：测试过程中团队有一些不太统一的意见，经过协商和讨论，最终达成一致，组员和组员之间的合作效率大大加快，有质有量的完成了此次测试。对整个测试项目的周期有了充分的了解，用例编写的效率大大提升，对复杂Bug有了更好的理解，对计划和总结的编写有了正确的认知。</p>]]></content>
    
    
    <categories>
      
      <category>软测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
      <tag>比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件操作</title>
    <link href="/post/16177/"/>
    <url>/post/16177/</url>
    
    <content type="html"><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h1 id="文件管理-IO操作"><a href="#文件管理-IO操作" class="headerlink" title="文件管理&#x2F;IO操作"></a>文件管理&#x2F;IO操作</h1><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><div class="code-wrapper"><pre><code class="hljs">  一、首先，计算机三大核心硬件     **CPU 内存 硬盘**     所有文件都被存在硬盘中，然后在读取到内存，再进行操作  二、文本编辑器读取文件的三个步骤     启动文本编辑器     将文件内容读取至内存     将数据显示到屏幕上  三、运行python程序的步骤     启动python解释器     把文件内容从硬盘读入内存     把文件内容当成Python语法识别  **::因此，无论在Python编译器内无论是什么后缀名都可以，只要文件是 文本文件 and 符合python语法即可运行::**</code></pre></div><h3 id="字符编码发展史"><a href="#字符编码发展史" class="headerlink" title="字符编码发展史"></a>字符编码发展史</h3><div class="code-wrapper"><pre><code class="hljs">  首先我们可以知道 计算机内部是用二进制存储的  高电平 —&gt; 1  低电平 —&gt; 0  那么就需要把二进制翻译  那么这个翻译的过程就是字符编码  #### ASCII码     采用**8位二进制码**     共可以表示128个不同的字符（数字，大小写字母，控制字符）     在ASCII中 数字 大写字母 小写字母 依次     ::可以形象记忆 **数大小**::     下面是三个常见字符的ACSII码</code></pre></div><table><thead><tr><th><strong>字符</strong></th><th><strong>ACSII码</strong></th></tr></thead><tbody><tr><td><strong>0</strong></td><td><strong>48</strong></td></tr><tr><td><strong>A</strong></td><td><strong>65</strong></td></tr><tr><td><strong>a</strong></td><td><strong>97</strong></td></tr></tbody></table><hr><div class="code-wrapper"><pre><code class="hljs">  #### GBK（中文字符、英文字符）     采用了16位二进制来存储，每个国家到最后都开发了自己的字符标准。  #### unicode字符编码     由于1988年在一次国际化开发的时候，每个国家都采用自己的字符编码标准，开发**通用标准**变得越来越重要，所以开发了**unicode**     1989年，ISO（国际标准化组织）发布了**UCS**     1990-1994年，unicode（万国码）被研发出来，其和GBK编码一样也采用16位编码     **2Bytes表示一个字符**     **复杂字，生僻字 会用4Bytes或者8Bytes作为表示**</code></pre></div><h2 id="IO问题"><a href="#IO问题" class="headerlink" title="IO问题"></a>IO问题</h2><div class="code-wrapper"><pre><code class="hljs">  **平均寻道时间**  7200/60 = 120  1000/120 = 8ms/2 = 4ms  **平均寻址时间**  5ms  **I/O延迟 = 平均寻道时间 + 平均寻址时间**  ::那么我们要减少程序运行的时间，就是要减少IO操作的时间::  ::也就是CPU要向内存要数据，而不是内存再对硬盘要数据。（尽量减少文件读写行为）::</code></pre></div><h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h3><div class="code-wrapper"><pre><code class="hljs">  是对unicode的精简  在内容中存的都是unicode编码（中介）  **编码和解码的概念**     编码：字符 —编码—&gt; Unicode —编码—&gt; UTF-8\GBK     解码：字符 &lt;—解码— Unicode &lt;—编码— UTF-8\GBK</code></pre></div><h2 id="Python3文件"><a href="#Python3文件" class="headerlink" title="Python3文件"></a>Python3文件</h2><p>   <strong>::Python3默认使用UTF-8来读取文件::</strong></p><p>   举个例子</p><img src="/post/16177/Image.png" class="" title="This is a picture"><p>   这是一个Python文件，我们<strong>使用了GBK编码的方式存储到了 硬盘</strong>（注意右下角）</p><p>   那么 我们接下来对这个Python文件进行编译运行</p><img src="/post/16177/Image(2).png" class="" title="This is a picture"><p>   报错了，那么我们来看，Non-UTF-8 code 不是UTF-8格式。</p><p>   我们将文件保存为GBK编码格式，然后执行<code>python3 index.py</code> 的时候，被读取到内存，内存会对做一次unicode转换，这时候就会出现错误。那么我们就需要在Python文件中添加<strong>文件头</strong></p><img src="/post/16177/Image(3).png" class="" title="This is a picture"><p>   ::这个<strong>文件头</strong>，必须添加在文件的首行，冒号后面的内容规定了Python编译器将会以什么编码方式来编译下面的语句。::</p><p>   增加了文件头，我们的代码就可以正常运行了。</p><p>   <strong>我们并不需要每次都写这个文件头，因为Python的默认文件编码方式就是UTF-8</strong></p><p>   那么我们可能会遇到的一个问题就是，在Python3中字符串可以正常显示，但是到Python2中字符串显示就是乱码，我们有三种解决方式。</p><div class="code-wrapper"><pre><code class="hljs">  &gt; 第一种方式，使用文件头  &gt; 第二种方式，尽量使用Python3，而不是Python2  &gt; 第三种方式，在Python2的字符串前面使用u</code></pre></div><p>   我们来看一段代码，这个文件是<strong>使用GBK格式保存在我们的硬盘上</strong>的</p><img src="/post/16177/Image(4).png" class="" title="This is a picture"><p>   我们是使用了Python2的编译器，对上面的代码执行结果如下。</p><img src="/post/16177/Image(5).png" class="" title="This is a picture"><p>   那么我们使用Python3点编译器执行</p><img src="/post/16177/Image(6).png" class="" title="This is a picture"><p>   代码没有任何问题。但是我们发现没有“这是另一个测试”这个语句无论在Python2还是Python3中都可以正常执行。</p><p>   我们看源代码的第四行，我们在字符串的前面加了u，说明这个字符串将会以UTF-8的编码格式被编码。所以无论在Python2和Python3中都不会有问题。</p><p>   ::因此我们要记住，在Python2中的字符串，为避免出现乱码问题，我们要在字符串前面加上u::</p><img src="/post/16177/Image(7).png" class="" title="This is a picture"><p>   我们再来看一段代码，第二行将我们的“和”编码（encode）成了GBK格式，赋值给了res，然后我们print一下，显示结果就是GBK格式的“和”，我们在对res进行解码（decode）那么我们的“和”字就又回来了。</p><p>   <strong>那么现在我们对于字符编码部分已经讲完了。</strong></p><hr><h2 id="Python操作文件"><a href="#Python操作文件" class="headerlink" title="Python操作文件"></a>Python操作文件</h2><p>Python为我们提供了操作文件的一个函数 <code>open()</code></p><p>这个函数提供了两种模式</p><h4 id="一、控制文件读写操作的模式"><a href="#一、控制文件读写操作的模式" class="headerlink" title="一、控制文件读写操作的模式"></a>一、控制文件读写操作的模式</h4><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td><strong>r</strong></td><td><strong>只读模式</strong></td></tr><tr><td><strong>w</strong></td><td><strong>只写模式</strong></td></tr><tr><td><strong>a</strong></td><td><strong>只追加写模式</strong></td></tr><tr><td><strong>+</strong></td><td><strong>不能单独使用，r+ 、w+、a+</strong></td></tr></tbody></table><p>   <strong>只追加写模式 和 只写模式的区别：</strong></p><p>   ::只写模式会将原有文件的内容进行覆盖，只追加写模式会在保留原有文件内容的基础上，对文件内容进行追加。::</p><h4 id="二、控制文件读写内容的模式"><a href="#二、控制文件读写内容的模式" class="headerlink" title="二、控制文件读写内容的模式"></a><strong>二、</strong>控制文件读写内容的模式</h4><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td><strong>t</strong></td><td><strong>读写都是以字符串（unicode）为单位的，指定参数<code>encoding = ’utf-8‘</code>  ，那么就说明限定死了，只能读取文本文件。</strong></td></tr><tr><td><strong>b</strong></td><td><strong>bytes模式&#x2F;二进制模式，可以是图片，视频</strong></td></tr></tbody></table><p><strong>::以上的两种模式，不能单独使用，必须要配合使用::</strong></p><p>我们Python要对文件进行管理，无非就是 <strong>打开文件——&gt;操作文件——&gt;关闭文件</strong></p><p>那么接下来，我们来了解open()这个函数</p><img src="/post/16177/Image(8).png" class="" title="This is a picture"><p>我们在和 index.py 相同的目录下新建了一个文本文档 a.txt</p><p>我们将返回值给了f变量，然后我们打印这个f变量，我们来看结果</p><img src="/post/16177/Image(9).png" class="" title="This is a picture"><p>编译器抛出了一个错误，不能找到文件，这是为什么呢？因为上面我们使用了 相对路径</p><p>::那么，我们就要引入一个 <strong>绝对路径和相对路径</strong> 的概念::</p><p>   绝对路径：我们在下面就是使用了绝对路径</p><img src="/post/16177/Image(10).png" class="" title="This is a picture"><p>   相对路径：就是在当前Python文件所在的路径中，找这个文件</p><p>   那么我们是不是只要用绝对路径，就不会出现错误了呢？</p><p>   当然不是这样的，相对路径的出现，可以避免因为不同电脑之间的文件路径不同造成的问题。</p><p>   例如，一个用户将文件存在&#x2F;Users&#x2F;Coodes&#x2F;Propy&#x2F;a.txt</p><p>   那么，我们上面通过写绝对路径的方式，就会导致报错，找不到文件</p><p>   这时候，我们通过写相对路径，就可以避免因为电脑文件路径不同造成的问题。</p><p>解决了这个问题，我们输出看看结果。</p><img src="/post/16177/Image(11).png" class="" title="This is a picture"><p>很奇怪的一个结果，我们暂时先放一下。</p><p>现在我们已经可以 打开文件 了</p><p>那么接下来就是 操作文件</p><img src="/post/16177/Image(12).png" class="" title="This is a picture"><p>我们直接上运行结果</p><p><code>f.read()</code>  就是对f这个对象，执行读取的操作。是向操作系统发送请求，请求读取这个文件的内容</p><p>这样我们就成功拿到了a.txt文件内的内容</p><p>⚠️::我们在对文件操作完以后，不要忘记关闭文件::</p><p>由于Python的垃圾回收机制，我们过多产生的对象，并不会对内存造成溢出等问题。但是我们还是要在操作系统层面将其关闭，不然由于操作系统过多打开的文件，也会对操作系统产生负担。</p><p><code>f.close()</code> 就是将文件在操作系统层面关闭。我们这么做以后<code>f.read()</code> 将产生错误</p><img src="/post/16177/Image(13).png" class="" title="This is a picture"><p><code>del f</code> 就是清除一个对象，在内存层面将该空间释放，但是我们一般不需要做这个操作，因为Python的垃圾回收机制会将该对象回收。</p><p>但是我们会发现一个问题，以上的写法，会导致在Windows平台上出现乱码问题，这是由于Windows平台使用的是GBK编码，而在Linux和Mac中，使用的则是UTF-8格式。</p><img src="/post/16177/Image(14).png" class="" title="This is a picture"><p>我们在open函数中，添加了一个encoding参数，这样在解码的时候就会告诉操作系统，会按照UTF-8的方式来打开文件，在read的时候，将会用UTF-8来转成unicode格式，这样就不会乱码了。</p><h3 id="with语法（上下文管理器）"><a href="#with语法（上下文管理器）" class="headerlink" title="with语法（上下文管理器）"></a>with语法（上下文管理器）</h3><img src="/post/16177/Image(15).png" class="" title="This is a picture"><p>   我们可以看到这两种都是一样的输出结果，但是第二种方式可以让我们省去<code>f.close</code>这个一个步骤。</p><h2 id="文件指针的概念"><a href="#文件指针的概念" class="headerlink" title="文件指针的概念"></a>文件指针的概念</h2><h3 id="rt模式"><a href="#rt模式" class="headerlink" title="rt模式"></a>rt模式</h3><p>   我们先来看一组代码</p><img src="/post/16177/Image(16).png" class="" title="This is a picture"><p>   按照道理来说，我们的两次读取结果应该是一样的。但是，我们来看实际结果</p><img src="/post/16177/Image(17).png" class="" title="This is a picture"><blockquote><p>是不是有点不太对劲，第二次为什么什么都没读到呢？</p></blockquote><p>   这就是文件指针，我们的r模式下，文件指针会跳到开始位置，然后f.read()就会一次性将文件读完，那么我们的文件指针是不是就到了文档的最后，因此我们第二次读取，就会什么结果都读不到了。</p><h3 id="wt模式下"><a href="#wt模式下" class="headerlink" title="wt模式下"></a>wt模式下</h3><p>   我们还是来看一组代码</p><img src="/post/16177/Image(18).png" class="" title="This is a picture"><p>   我们可以看到，我们在wt模式下，传入了一个不存在的文件路径，那么该文件就会被新建</p><img src="/post/16177/Image(19).png" class="" title="This is a picture"><p>   那么当我们的文件存在了，并且有内容的时候，使用wt模式将会让内容被清空，所以不要使用wt来操作重要的文件</p><p>   我们现在来学一个<code>f.write()</code>这是一个写入函数</p><img src="/post/16177/Image(20).png" class="" title="This is a picture"><p>   在这组代码中，我们可以看到我们要往文件中写入内容，我们来猜一下结果<strong>🤔</strong></p><div class="code-wrapper"><pre><code class="hljs other">别后相思空一水重来回首已三生</code></pre></div><div class="code-wrapper"><pre><code class="hljs other">重来回首已三生</code></pre></div><div class="code-wrapper"><pre><code class="hljs other">别后相思空一水重来回首已三生</code></pre></div><p>不知道你答对了没。我们可以看到在第一个f.write()下，我们有一个换行符，这时候文件指针已经到了第2行的开头，然后再次执行f.write()所以结果就是和第三个一样。</p><h2 id="at模式下"><a href="#at模式下" class="headerlink" title="at模式下"></a>at模式下</h2><p>   我们还是来看一组代码</p><img src="/post/16177/Image(21).png" class="" title="This is a picture"><p>   我们可以看到，我们在at模式下，和wt一样传入一个不存在的文件路径，那么该文件就会被新建</p><img src="/post/16177/Image(22).png" class="" title="This is a picture"><p>   d.txt本来就有“直道相思了无益”，我们这样写代码，运行的结果就是如下</p><img src="/post/16177/Image(23).png" class="" title="This is a picture"><p>   这是因为在at模式下，我们的文件指针在文件的最后，也就是“未妨惆怅是清狂”会从“益”字后面开始追加写。</p><p><strong>::w和a模式的区别总结：w模式每次都会清空文件，然后让文件指针处于开头。a模式则是每次都是在文件的最后做追加。::</strong></p><h3 id="r-模式"><a href="#r-模式" class="headerlink" title="r+模式"></a>r+模式</h3><img src="/post/16177/Image(24).png" class="" title="This is a picture"><p>   我们来分析一下，第4行代码，会在d.txt文件中产生什么结果，是“李商隐”出现在文件的开头，还是文件的末尾。</p><img src="/post/16177/Image(25).png" class="" title="This is a picture"><p>   结果如上，我们可以分析一下，在第二行f.read()作用下，我们的文件指针已经由文件的开头，指向了最后。那么我们再f.write()就是对文件的末尾执行操作。</p><p>   那么我们将f.read注释掉，并执行代码</p><img src="/post/16177/Image(26).png" class="" title="This is a picture"><div class="code-wrapper"><pre><code class="hljs">  那我们的r本来就是在文件开始位置读取，r+是让只读多了写的功能。并且会把原来的内容覆盖掉。</code></pre></div><h3 id="w-模式"><a href="#w-模式" class="headerlink" title="w+模式"></a>w+模式</h3><img src="/post/16177/Image(27).png" class="" title="This is a picture"><p>   我们会发现在w+模式下，肯定都会先清空文件，然后对文件执行操作，我们执行了f.read()那么自然读取不到数据。</p><img src="/post/16177/Image(28).png" class="" title="This is a picture"><p>   我们先写入数据，文件指针此时在文件的最后，那么我们再读取数据，自然读不到数据。然后再写入数据，自然是从文件指针所在位置开始写数据。</p><h3 id="a-模式"><a href="#a-模式" class="headerlink" title="a+模式"></a>a+模式</h3><p>   <strong>a模式下，文件指针只会跳到文件末尾，所以我们使用f.read()自然也读不到任何数据。</strong></p><h3 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h3><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>x模式</td><td>文件不存在就创建文件，文件存在就报错，不可读，可写</td></tr><tr><td>U模式</td><td>已被弃用，解决的是\r \n的问题</td></tr></tbody></table><hr><h3 id="b模式"><a href="#b模式" class="headerlink" title="b模式"></a>b模式</h3><h3 id="rb模式下"><a href="#rb模式下" class="headerlink" title="rb模式下"></a>rb模式下</h3><img src="/post/16177/Image(29).png" class="" title="This is a picture"><p>   使用rb模式会，以bytes模式&#x2F;二进制模式进行读取，那么我们输出的结果是以二进制的显示方式，但是Python对此作了优化，以十六进制显示，类型为Bytes类型。</p><p>   那么如果是用rb模式读取文本文件呢？</p><img src="/post/16177/Image(30).png" class="" title="This is a picture"><p>   我们已经知道，b模式是以bytes模式&#x2F;二进制模式对文件进行读取，那么就决定了，其什么类型的文件都可以读取，但是读取的结果是二进制的结果（别看显示的结果是十六进制，这是Python为我们做的优化）所以我们要对读取的结果进行解码。<strong>wb模式也同义。</strong></p><h2 id="按行读取文件-指定read-的参数"><a href="#按行读取文件-指定read-的参数" class="headerlink" title="按行读取文件&#x2F;指定read()的参数"></a>按行读取文件&#x2F;指定read()的参数</h2><p>   f.read()是一次性将文件读入内存的，那么如果我们的文件特别大，大到50个G，我们就会产生问题。那么我们该如何解决呢，那我们就可以使用按行读取文件&#x2F;给read()指定参数。</p><p>   来看两组示例代码</p><img src="/post/16177/Image(31).png" class="" title="This is a picture"><p>   这两组代码的注释，已经将代码释意讲清楚了，自己看看。</p><h3 id="🌟实例"><a href="#🌟实例" class="headerlink" title="🌟实例"></a>🌟实例</h3><p>   我们现在已经学会了用文件的读取和写入，那么我们试试看来做一个简单的项目———拷贝和粘贴</p><p>   我们先来看一个Linux下的命令 cp命令</p><div class="code-wrapper"><pre><code class="hljs other">cp 源文件 目标文件 ------&gt; 将源文件的文件拷贝至目标文件</code></pre></div><p>   那么我们先来分析思路，我们先用rb模式读取源文件f1的内容，然后在使用wb模式将文件内容写到目标文件f2。思路很简单对吧</p><p>   但是如果我们读取的是很大的文件，那么会发生什么，所有文件数据被读取到内存，那肯定是我们不想见到的，那我们就可以按行读入。<strong>来看代码。</strong></p><img src="/post/16177/Image(32).png" class="" title="This is a picture"><p>   我们首先输入了两个路径，然后会从两个路径中读取文件，第二个open()由于是wb模式就是会先创建文件，然后进入while循环，f1会被一次读取1024个字节，然后判断是不是到了文档的结束，未结束就写入。<strong>你可以自己试试。</strong><del>如果我们想要实现cp命令的语法，我们可以使用split(‘ ’)来分割字符串。</del></p><h2 id="readline和readlines的用法"><a href="#readline和readlines的用法" class="headerlink" title="readline和readlines的用法"></a>readline和readlines的用法</h2><p>   readline 一次读一行</p><p>   readlines 一次性读很多 行 也就是全部读完，并且返回一个<strong>列表</strong>的形式</p><p>   <strong>因此readlines和read在遇到文件过大的时候，就会产生风险，当然所有数据都在一行，那么也会产生风险，最为保险的方式，仍然是向read传参数。</strong></p><h2 id="writelines的用法"><a href="#writelines的用法" class="headerlink" title="writelines的用法"></a>writelines的用法</h2><p>   wirtelines 的参数是一个列表，类似于对write做循环。</p><blockquote><p><strong>思考：我们怎么在wb的模式下，用writelines对文本文档进行写入呢？</strong></p></blockquote><blockquote><p>分析：那我们并不能直接传入字符串，而是要对列表内的每一个元素都进行一下编码，也就是都加上<code>.encode(‘utf-8’)</code>就可以解决问题</p></blockquote><p>   但是其实如果我们要<strong>写入的数据是字母或数字</strong>，那我们这样的操作就有些多余，<strong>我们只需要在字符串前面加一个b即可，就像这样<code>b’abc’</code>就可以得到bytes类型。（思路一）</strong></p><p>   或者我们可以换种思路，将这些要传入的数据转成bytes类型，我们只要在字符串外面套一层bytes，并加上<code>encoding=‘utf-8’</code>的指定编码方式即可达到一样的效果。<strong>（思路二）</strong></p><p>   那我们的中文该怎么解决呢？相信你可能已经尝试过去b一个中文，但是会提示错误。</p><div class="code-wrapper"><pre><code class="hljs">  `SyntaxError: bytes can only contain ASCII literal characters.`</code></pre></div><p>   就算我们的英文真的不怎么样，加粗的三个单词（只能 包含 ASCII）说明b的局限性，我们就可以使用思路二。</p><img src="/post/16177/Image(33).png" class="" title="This is a picture"><p>   <strong>但是我们要注意，writelines并不是按行写入的。</strong></p><p>   因此我们得到的结果是</p><div class="code-wrapper"><pre><code class="hljs other">a你好</code></pre></div><div class="code-wrapper"><pre><code class="hljs other">a你好</code></pre></div><h2 id="常见的几种属性（了解即可）"><a href="#常见的几种属性（了解即可）" class="headerlink" title="常见的几种属性（了解即可）"></a>常见的几种属性（了解即可）</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>f.readable()</td><td>判断文件是否可读</td></tr><tr><td>f.writable</td><td>判断文件是否可写</td></tr><tr><td>f.closed</td><td>判断当前文件是否关闭</td></tr><tr><td>f.encoding</td><td>当前文件的编码方式，如果是b模式则没有该属性</td></tr><tr><td>f.name</td><td>获取当前文件名</td></tr></tbody></table><hr><h2 id="随心所欲😍控制文件指针"><a href="#随心所欲😍控制文件指针" class="headerlink" title="随心所欲😍控制文件指针"></a>随心所欲😍控制文件指针</h2><p>   前面我们都是用f.read()来控制文件指针，我们无法精确控制文件指针的位置，只能任由它算。</p><p>   那么我们该怎么控制我们的文件指针读到哪里呢？</p><p>   <strong>文件指针移动的每次单位都是 字节 ，只有在rt模式下移动的单位才是“字符”</strong></p><p>   （但是其实说，本质t模式下的移动也是字节个数，只是t模式会自动做出转换）</p><p>   可以看看下面的例子</p><img src="/post/16177/Image(34).png" class="" title="This is a picture"><h2 id="f-seek-学习"><a href="#f-seek-学习" class="headerlink" title="f.seek()学习"></a>f.seek()学习</h2><div class="code-wrapper"><pre><code class="hljs">  我们来学一个**f.seek(指针移动数量，参照位置)**，这个函数共需要传入两个参数，第一个是指针移动的字节数，第二个是参照位置。     &gt; **模式0**        &gt; 文件指针从文件开头3        &gt; `f.seek(5,0) #5`       `f.seek(2,0) #2`     &gt; **模式1**        &gt; 当前文件指针参照位置        &gt; `f.seek(5,1) #5`       `f.seek(2,1) #7`     &gt; **模式2**        &gt; 参照文件末尾来做移动，那么**传入的值就应该是负数**        &gt; `f.seek(-5,2) #文件长度-5`       `f.seek(-2,2) #文件长度-2`  在t模式还是在b模式seek移动的单位都是字节，只有在t模式下的read(n)，n才表示字符，其他情况下都是字节  &gt; seek的模式1和模式2都不能在 t模式 下使用，在b模式下，三种模式都可以使用。  那么我们怎么获取当前指针的位置呢？  `f.tell() 这个方法会告诉我们当前指针处于哪个位置。`  来看一组代码</code></pre></div><img src="/post/16177/Image(35).png" class="" title="This is a picture"><div class="code-wrapper"><pre><code class="hljs">  分析：我们可以看到，我们执行完  f.read()后文件指针移动到了45，分析一下，在e.txt中字符的数量是15个，我们可以除一下每个字符都占了3个字节，**但是说的准确一点，每个中文字符都占了3个字节。**于是我们执行f.seek(3,0)，我们的文件指针就移动到了第3个字节，然后我们再执行f.read()，就是从第3个字节开始，读到末尾，那么“星”字就会被省去。结果就是“散白鸥三四点，数笔横塘秋意。”（**不要忘记对结果进行decode解码才能正常显示**。）  **seek的其他模式，也是同理，无非就是文件指针移动到哪里，操作到哪里。**</code></pre></div><h3 id="🌟实例-1"><a href="#🌟实例-1" class="headerlink" title="🌟实例"></a>🌟实例</h3><div class="code-wrapper"><pre><code class="hljs">  我们现在已经会了很多的操作了，可以基本实现对文件的读写，那么我们接下来完成一个项目，在Linux下有一个tail命令，可以监控文件的变化，我们来重现一下，我们先来看看这个命令的具体说法。</code></pre></div><div class="code-wrapper"><pre><code class="hljs other">tail [参数] [文件]</code></pre></div><div class="code-wrapper"><pre><code class="hljs">  那么我们该怎么复现呢？？（[效果预览](https://www.aliyundrive.com/s/RULjHHK2BuY)）  可以看到我们使用 ls.py 输入一个数字，然后就会被左边 tail-rw.py 程序监控到。  那么是怎么做到的呢？？我们先来看 ls.py 看看它做了什么</code></pre></div><img src="/post/16177/Image(36).png" class="" title="This is a picture"><div class="code-wrapper"><pre><code class="hljs">  显而易见， ls.py 是往 user.log **末尾**（所以用at模式）写“充值了多少”，我们监控也是监控**末尾**部分，那么我们来分析边 tail-rw.py 该怎么写。  首先，我们监控文件肯定是读文件（这应该不需要解释吧）那我们用什么模式呢？读文件嘛，那r肯定逃不掉了，user.log其本质也可以看成一个文本文件，我们用t模式就可以解决。  &gt; 思考：我们刻意强调了**末尾**，说明我们这个文件指针是要从tail-rw.py开始运行就在末尾，我们该怎么实现呢？  &gt; 分析：  &gt; 首先来一遍f.read()的方式，但是随着user.log文件内容的越来越多，这种方式就是不可取的。（方式一）  &gt; 将读文件的模式改成a+t，a模式一开始就会把文件指针移动到末尾，但是a是追加写，所以要加一个+，让它也有读的功能，但是这个方法并不推荐，读就是读，写就是写，最好不要用这种方式。（方式二）  &gt; 在开始前，就用f.seek(0,2)将文件指针移动到最后。（方式三）  好啦理解了，我们就来看代码</code></pre></div><img src="/post/16177/Image(37).png" class="" title="This is a picture"><div class="code-wrapper"><pre><code class="hljs">  我们在指针移动到末尾后，做了一个while死循环，并用f.readline()读取了下一行，赋值给了res，那么当我们读到内容的时候，res的值就是True，所以我们就会将其打印出来。这个功能就被复现完成了。</code></pre></div><h2 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h2><div class="code-wrapper"><pre><code class="hljs">  前面我们已经学会了读文件和写文件，但是我们只能实现对文件的覆盖，不能修改。  比如我们有一个需求我们要将f.txt内的“我喜欢你”改成“我不喜欢你”怎么办呢？</code></pre></div><img src="/post/16177/Image(38).png" class="" title="This is a picture"><div class="code-wrapper"><pre><code class="hljs">  是不是就是像上面一样？但是f.txt的结果是</code></pre></div><div class="code-wrapper"><pre><code class="hljs other">我喜欢你不</code></pre></div><div class="code-wrapper"><pre><code class="hljs">  为什么呢？我们的代码逻辑是正确的啊，at文件指针在最后，然后f.seek(3,0)将指针移动到了第3个字节处，然后写入“不”。  但是在硬盘内的数据是**不能“插入”，只能覆盖**。然而在内存内的数据可以实现插入。因此我们所以修改文件，都是先读入内存，修改，覆盖文件到硬盘。</code></pre></div><img src="/post/16177/Image(39).png" class="" title="This is a picture"><div class="code-wrapper"><pre><code class="hljs">  再来看第二个需求，我们要将一个文档内的所有“、”替换成“，”。</code></pre></div><img src="/post/16177/Image(40).png" class="" title="This is a picture"><div class="code-wrapper"><pre><code class="hljs">  注释已经将清楚了，我们来分析一下这两种方式的优缺点  第一种方式，将文件所有内容都读入内存，对内存不太友好，但是对于用户体验来说，速度快，不是逐行处理，因此文本编辑器基本上用该方式。  第二种方式，逐行读入内存，对内存较为友好，但是并不适合文本编辑器。</code></pre></div><p>至此，Python文件部分就全部学完了</p><p>（点击完结撒花可前往“Linux文件命令”页面，尝试复现几个命令吧）</p><blockquote><h1 id="完结撒花🎉🎉🎉"><a href="#完结撒花🎉🎉🎉" class="headerlink" title="完结撒花🎉🎉🎉"></a>完结撒花<a href="https://blog.csdn.net/qq_43634001/article/details/103993281">🎉🎉🎉</a></h1></blockquote>]]></content>
    
    
    <categories>
      
      <category> Python教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑处理及循环</title>
    <link href="/post/61882/"/>
    <url>/post/61882/</url>
    
    <content type="html"><![CDATA[<h1 id="逻辑处理及循环"><a href="#逻辑处理及循环" class="headerlink" title="逻辑处理及循环"></a>逻辑处理及循环</h1><h2 id="布尔值扩展"><a href="#布尔值扩展" class="headerlink" title="布尔值扩展"></a>布尔值扩展</h2><p>在01章，我们已经有所了解比较运算符和逻辑运算符了，接下来我们对它们的结果<strong>布尔值</strong>再做一些扩展。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 显式布尔值</span><span class="hljs-comment"># 比如明天是周六，必须满18周岁才可以进入网吧</span>day = <span class="hljs-string">&#x27;周六&#x27;</span>age = <span class="hljs-number">21</span><span class="hljs-built_in">print</span>(day == <span class="hljs-string">&#x27;周六&#x27;</span>) <span class="hljs-comment"># True</span><span class="hljs-built_in">print</span>(age &gt;= <span class="hljs-number">18</span>) <span class="hljs-comment"># True</span><span class="hljs-comment"># 隐式布尔值</span><span class="hljs-comment"># 0 None 空（空字符串，空列表，空字典） --&gt; False</span><span class="hljs-comment"># 其他的所有的值，都是True</span></code></pre></div><h2 id="if条件语句（流程控制）"><a href="#if条件语句（流程控制）" class="headerlink" title="if条件语句（流程控制）"></a>if条件语句（流程控制）</h2><p>当遇到多个条件需要分别处理的时候，这时候就要用到if条件语句，if语句的格式如下</p><div class="code-wrapper"><pre><code class="hljs python">主代码块<span class="hljs-keyword">if</span> condition:    子代码块    子代码块主代码块</code></pre></div><p>要知道Python的语法是<strong>“以缩进的方式来标识代码块”</strong>，这就导致使用Tab键来标识代码块，或者很多自带的代码编辑器也会帮我们做好代码的格式化。<strong>if条件语句的执行流程如下图所示</strong></p><img src="/post/61882/Image.png" class="" title="This is a picture"><p>当某个条件不成立的时候，我们可以使用else语句</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> condition_1:    statement_block_1<span class="hljs-keyword">else</span>:    statement_block_2</code></pre></div><p>当条件成立的时候，就执行<code>statement_block_1</code>语句块的代码，当条件不成立的时候，就执行<code>statement_block_2</code>语句的代码块。</p><p>当然你还想加入多个条件，以处理不同的情况可以</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> condition_1:    statement_block_1<span class="hljs-keyword">elif</span> condition_2:    statement_block_2<span class="hljs-keyword">else</span>:    statement_block_3</code></pre></div><ul><li>如果 <code>condition_1</code> 为 True 将执行 <code>statement_block_1</code> 块语句</li><li>如果 <code>condition_1</code> 为False，将判断 <code>condition_2</code></li><li>如果<code>condition_2</code> 为 True 将执行 <code>statement_block_2</code> 块语句</li><li>如果 <code>condition_2</code> 为False，将执行<code>statement_block_3</code>块语句</li></ul><p>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else。</strong></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>计算机出现的目的，就是代替人类去进行重复的劳动，于是就出现了循环。首先来讲<strong>基于条件的循环</strong></p><p>语法如下，和</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 判断条件(condition)：    执行语句(statements)……</code></pre></div><p><code>condition</code>就是循环条件，当循环条件不满足的时候，就跳出循环。当循环条件满足的时候，就依次执行循环体，执行完循环体后会再次去判断循环条件，如此继续。来看流程图</p><img src="/post/61882/Image(2).png" class="" title="This is a picture"><p>操作执行逻辑就如上图所示，那我们来看实际的代码</p><div class="code-wrapper"><pre><code class="hljs python">num = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> num &lt; <span class="hljs-number">10</span>:    <span class="hljs-built_in">print</span>(num)</code></pre></div><p>首先来看这一份代码，在粘贴进你的代码编辑器之前，要先注意，这会是一个死循环。</p><p>我们要设置动态条件，否则这个num就一直会是0，一直都在进行循环。我们应该这样改写</p><div class="code-wrapper"><pre><code class="hljs python">num = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> num &lt; <span class="hljs-number">10</span>:    <span class="hljs-built_in">print</span>(num)    num += <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;循环执行完毕&#x27;</span>)</code></pre></div><p>这样的代码会依次输出0～9，然后在最后输出“循环执行完毕”，我们分析循环的时候，可以采用“条件分析”，比如上面这段代码，每次循环+1，<code>0，1，2，3，4，5，6，7，8，9</code>  当你想打出10的时候，你要分析，10&lt;10不成立，那就不能要。</p><p>我们知道while循环是基于条件的循环，那么我们的条件始终成立，代码就会陷入死循环，那怎么写一个死循环呢？直接条件写一个布尔值就可以了不就行了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2&#x27;</span>)</code></pre></div><p>你应该明白第二种写法的原理，1相当于隐式布尔值。</p><p>并不是所有死循环都会对CPU造成消耗，只有纯运算，无IO操作的死循环才是致命的。</p><h2 id="退出while循环的方式"><a href="#退出while循环的方式" class="headerlink" title="退出while循环的方式"></a>退出while循环的方式</h2><h4 id="第一种，修改循环的条件"><a href="#第一种，修改循环的条件" class="headerlink" title="第一种，修改循环的条件"></a>第一种，修改循环的条件</h4><div class="code-wrapper"><pre><code class="hljs python">c = <span class="hljs-literal">True</span>num = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> c:    <span class="hljs-built_in">print</span>(num)    num = num + <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">10</span>:        c = <span class="hljs-literal">False</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;本次循环结束&#x27;</span>)</code></pre></div><p>这个代码的结果也是输出0～9，和直接写条件<code>num &lt; 10</code> 的结果也是一样，只是我们在其中加了一个条件判断，判断当num &gt; 10（大于10的时候，则不满足num &lt; 10)的时候，则循环跳出。但是执行完c &#x3D; False 后并不会立刻跳出循环，而是继续执行完当次循环后，再退出。就是结果会输出“本次循环结束”</p><h4 id="第二种，break退出"><a href="#第二种，break退出" class="headerlink" title="第二种，break退出"></a>第二种，break退出</h4><div class="code-wrapper"><pre><code class="hljs python">c = <span class="hljs-literal">True</span>num = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> c:    <span class="hljs-built_in">print</span>(num)    num = num + <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">10</span>:        <span class="hljs-keyword">break</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;本次循环结束&#x27;</span>)</code></pre></div><p>break是<strong>立即结束本层循环</strong>，就是立刻结束了，不会输出“本次循环结束”。</p><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>我们现在来学习循环嵌套，就是在一个循环里套另外一个循环。来看一个例子。</p><div class="code-wrapper"><pre><code class="hljs python">stlist = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>i = <span class="hljs-number">0</span>s = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(stlist):    s = s + stlist[i]    i = i + <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">13</span> <span class="hljs-keyword">and</span> i &lt;= <span class="hljs-built_in">len</span>(stlist)):        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(stlist):            <span class="hljs-keyword">break</span>        s = stlist[i] + s        i = i + <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(s)</code></pre></div><p>这段代码有两个循环，你可以尝试分析一下，在下面选择一下答案</p><div class="code-wrapper"><pre><code class="hljs python">abcdefghijklmnopqrstuvwxyz</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">zyxwvutsrqponabcdefghijklm</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">nopqrstuvwxyzabcdefghijklm</code></pre></div><p>你选对了么？来分析一下。首先我们定义了一个全是小写字母，然后和索引i &#x3D; 0，进入循环后，首先会 <code>abcdefghijklm</code> ，当i等于13的时候，便会进入第二层循环，这层循环是将依次将<code>n、o…</code> 依次连接到字符的前端，当我们的i和stlist的长度一致的时候，便会break退出循环，第一层循环也随之退出。</p><h2 id="continue结束循环"><a href="#continue结束循环" class="headerlink" title="continue结束循环"></a>continue结束循环</h2><p>continue是结束本次循环，比如，我们需要<strong>输出0-9之间的数字，但是不需要4</strong>，我们该怎么写</p><div class="code-wrapper"><pre><code class="hljs python">i = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">10</span>:    <span class="hljs-keyword">if</span> i == <span class="hljs-number">4</span>:        <span class="hljs-keyword">continue</span>    <span class="hljs-built_in">print</span>(i)    i += <span class="hljs-number">1</span></code></pre></div><p>但是上面这段代码运行后，会在输出0～3后，程序暂停。因为代码当i等于4的时候代码进入if语句，continue直接退出本次循环，然而此时i也没有改变，于是再次进入循环也是一样，于是就进入死循环。所以我们应该在i&#x3D;4的时候，也将i+1，完整代码如下</p><div class="code-wrapper"><pre><code class="hljs python">i = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">10</span>:    <span class="hljs-keyword">if</span> i == <span class="hljs-number">4</span>:        i += <span class="hljs-number">1</span>        <span class="hljs-keyword">continue</span>    <span class="hljs-built_in">print</span>(i)    i += <span class="hljs-number">1</span></code></pre></div><p>在continue前添加任何同级代码，并没有任何意义，都会被continue跳过。</p><h3 id="结束循环的几种方式"><a href="#结束循环的几种方式" class="headerlink" title="结束循环的几种方式"></a>结束循环的几种方式</h3><table><thead><tr><th><strong>结束循环方式</strong></th><th><strong>结束循环位置</strong></th></tr></thead><tbody><tr><td>break</td><td>本层循环</td></tr><tr><td>continue</td><td>本次循环</td></tr><tr><td>变量+True</td><td>运行完本次循环，下次不再运行</td></tr></tbody></table><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环，相对于while循环来说，有着更加简洁的循环取值语法，<strong>循环取值又称遍历</strong></p><p>可以遍历的（可迭代对象）：列表、字典、字符串等。（字符串是串，所以也可以遍历每个字符）</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 变量名 <span class="hljs-keyword">in</span> 可迭代对象：循环体</code></pre></div><p>for循环的语法如上，我们来看一个for循环的应用举例</p><img src="/post/61882/Image(3).png" class="" title="This is a picture"><p>我们来看这个循环执行的过程，我们用i来作为一个临时变量，当遇到第一个值的时候，会把“赵”赋值给i，然后打印出来，但是我们加上了xx（字符串的连接），所以输出是“赵xx”。后面依次。</p><p>for循环能做的事情，while循环都可以做，上面的代码我们只需要让while循环遍历0～3即可，然后根据索引去获得对应的值，然后进行操作。代码如下。</p><div class="code-wrapper"><pre><code class="hljs python">i = <span class="hljs-number">0</span><span class="hljs-comment"># i &lt; len(l) 等价于 i &lt; 4 (0~3)</span><span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(l):    <span class="hljs-built_in">print</span>(l[i] + <span class="hljs-string">&#x27;xx&#x27;</span>)    i += <span class="hljs-number">1</span> <span class="hljs-comment"># i = i + 1</span></code></pre></div><p><strong>for循环也可以用break continue等控制循环语句。</strong></p><h3 id="for循环字典"><a href="#for循环字典" class="headerlink" title="for循环字典"></a>for循环字典</h3><div class="code-wrapper"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;female&#x27;</span>&#125;<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dic:    <span class="hljs-built_in">print</span>(i)</code></pre></div><p>你觉得循环的结果是什么，其实我们可以对比来看，列表的i是索引，那字典的i</p><p>很明显了吧，是key。结果如上</p><div class="code-wrapper"><pre><code class="hljs python">nameagegender</code></pre></div><p>那我们要获取到字典的值，是不是只要 <code>dic[i]</code> 就可以获得对应的值了。</p><h2 id="range介绍"><a href="#range介绍" class="headerlink" title="range介绍"></a>range介绍</h2><p>当我们要让for循环执行指定循环次数，那该怎么做呢？这时候range的功能就出现了。</p><div class="code-wrapper"><pre><code class="hljs python">l = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):    l.append(i)<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8]</span><span class="hljs-comment"># 上面的代码解析一下，我们创建了一个l变量，并且给它一个空列表</span><span class="hljs-comment"># 然后在循环体中用，l.append(i)将当前i的值添加到列表内，这样就可以得到range的取值</span><span class="hljs-comment"># range(9)得到了0～8的数字，说明这是符合&quot;顾头不顾尾&quot;的原则的 当然我们也可以指定起始数字</span>l = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">9</span>):    l.append(i)<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [1, 2, 3, 4, 5, 6, 7, 8]</span><span class="hljs-comment"># 当然也可以指定range的步长，在while循环中，步长可以通过i = i + 步长来实现</span><span class="hljs-comment"># range(0,9,2) </span>l = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>):    l.append(i)<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [0, 2, 4, 6, 8]</span></code></pre></div><p>在Python2中，range是按照要求为你生成一个列表，而在Python3中，则是给你一个迭代器。如果你要循环一亿次，那么Python2就会生成一个包含一亿元素的列表，这对你内存的消耗是很大的，而Python3则是给你一个迭代器。当然这不重要。</p><h1 id="结束了，关于逻辑处理和循环就讲完了-🌈🌈🌈"><a href="#结束了，关于逻辑处理和循环就讲完了-🌈🌈🌈" class="headerlink" title="结束了，关于逻辑处理和循环就讲完了 🌈🌈🌈"></a>结束了，关于逻辑处理和循环就讲完了 🌈🌈🌈</h1>]]></content>
    
    
    <categories>
      
      <category> Python教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本数据类型（详）</title>
    <link href="/post/32119/"/>
    <url>/post/32119/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型（详）"><a href="#基本数据类型（详）" class="headerlink" title="基本数据类型（详）"></a>基本数据类型（详）</h1><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><h3 id="字符串的内置操作"><a href="#字符串的内置操作" class="headerlink" title="字符串的内置操作"></a>字符串的内置操作</h3><p>首先字符串内置的操作有**，::索引取值、切片、strip去除空格、split拆分、长度Len、成员运算in和not in::**这些。</p><p>   <strong>索引取值：</strong>Python为所有的由多个元素组成按顺序排列的，都设置了索引的概念，因此我们可以通过索引取到对应的某个值，当然也可以反向索引</p><div class="code-wrapper"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;张xx&#x27;</span><span class="hljs-built_in">print</span>(name[<span class="hljs-number">0</span>]) <span class="hljs-comment"># 张</span><span class="hljs-built_in">print</span>(name[-<span class="hljs-number">1</span>]) <span class="hljs-comment"># x</span></code></pre></div><p><strong>切片：</strong>可以将我们的字符串按照索引将区域内的值取出来，生成新的字符串，原有字符串不发生改变。</p><div class="code-wrapper"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;好好学习，天天向上。&#x27;</span><span class="hljs-built_in">print</span>(info[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]) <span class="hljs-comment"># 好好学习</span></code></pre></div><p>注意 “习” 的索引号应该是3，<strong>但是Python有个“顾头不顾尾”这一个说法，因此我们要将索引+1</strong></p><div class="code-wrapper"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;好好学习，天天向上。&#x27;</span><span class="hljs-comment"># 第二个索引号不写，表示从第一个索引号（0）开始全部取完</span><span class="hljs-built_in">print</span>(info[<span class="hljs-number">0</span>:]) <span class="hljs-comment"># 好好学习，天天向上。</span><span class="hljs-comment"># 省去第一个索引号不写，表示从0开始取到停止</span><span class="hljs-built_in">print</span>(info[:<span class="hljs-number">4</span>]) <span class="hljs-comment"># 好好学习</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs other">info = &#x27;好好学习，天天向上。&#x27;print(info[0:4:2]) # 好学</code></pre></div><p>切片还可以指定步长，索引值0，2（由于“顾头不顾尾”的说法）因此结果是“好学”</p><p>当然还有反向步长，如果我们将步长值设为-1，第一个和第二个索引都不设置，就可以得到一个反向字符串了</p><div class="code-wrapper"><pre><code class="hljs other">info = &#x27;好好学习，天天向上。&#x27;print(info[::-1])  # 。上向天天，习学好好</code></pre></div><p><strong>strip去除空格：</strong>不提供任何参数的时候，<strong>去除字符串左右</strong>两边的空格，提供一个字符串作为参数的时候，可以将字符串左右两边的字符去除了</p><div class="code-wrapper"><pre><code class="hljs other">info = &#x27;。。/好好学习，天天向上。/&#x27;print(info.strip(&#x27;。/&#x27;))  # 好好学习，天天向上</code></pre></div><p><strong>split拆分：</strong>当不提供任何参数的时候，默认使用空格进行拆分，当然也可以指定分隔符进行拆分，同时也可以指定拆分次数。<strong>返回结果为列表。</strong></p><div class="code-wrapper"><pre><code class="hljs other">info = &#x27;好好 学习 天天 向上&#x27;print(info.split())  # [&#x27;好好&#x27;, &#x27;学习&#x27;, &#x27;天天&#x27;, &#x27;向上&#x27;]info = &#x27;好好，学习，天天，向上&#x27;print(info.split(&#x27;，&#x27;))  # [&#x27;好好&#x27;, &#x27;学习&#x27;, &#x27;天天&#x27;, &#x27;向上&#x27;]# 指定拆分次数，即当拆分到1个的时候，就不再拆分print(info.split(&#x27;，&#x27;, 1))  # [&#x27;好好&#x27;, &#x27;学习，天天，向上&#x27;]</code></pre></div><p><strong>长度len ：</strong>不仅可以计算字符串的字符个数，还可以计算列表，字典的元素个数</p><div class="code-wrapper"><pre><code class="hljs other">info = &#x27;好好 学习 天天 向上&#x27;print(len(info), type(len(info)))  # 11 &lt;class &#x27;int&#x27;&gt;</code></pre></div><p><strong>成员运算：</strong>可以判断某个字符串是否在某个字符串内</p><div class="code-wrapper"><pre><code class="hljs other">info = &#x27;好好 学习 天天 向上&#x27;print(&#x27;好好&#x27; in info)  # True</code></pre></div><p><strong>其他操作：</strong></p><div class="code-wrapper"><pre><code class="hljs python">info = <span class="hljs-string">&#x27;=/A-B-c-D/=&#x27;</span><span class="hljs-comment"># .lstrip()和.rstrip()</span><span class="hljs-comment"># 和strip()一致，只是l代表left r代表right</span><span class="hljs-built_in">print</span>(info.lstrip(<span class="hljs-string">&#x27;=/&#x27;</span>))  <span class="hljs-comment"># A-B-c-D/=</span><span class="hljs-built_in">print</span>(info.rstrip(<span class="hljs-string">&#x27;=/&#x27;</span>))  <span class="hljs-comment"># =/A-B-c-D</span><span class="hljs-comment"># .rsplit() 从右向左进行分割</span><span class="hljs-built_in">print</span>(info.split(<span class="hljs-string">&#x27;-&#x27;</span>))  <span class="hljs-comment"># [&#x27;=/A&#x27;, &#x27;B&#x27;, &#x27;c&#x27;, &#x27;D/=&#x27;]</span><span class="hljs-built_in">print</span>(info.rsplit(<span class="hljs-string">&#x27;-&#x27;</span>))  <span class="hljs-comment"># [&#x27;=/A&#x27;, &#x27;B&#x27;, &#x27;c&#x27;, &#x27;D/=&#x27;]</span><span class="hljs-comment"># 当然 从左往右 和 从右往左 全部分割完肯定没区别</span><span class="hljs-comment"># 当我们指定第二个参数的时候就有区别了</span><span class="hljs-built_in">print</span>(info.split(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># [&#x27;=/A&#x27;, &#x27;B-c-D/=&#x27;]</span><span class="hljs-built_in">print</span>(info.rsplit(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># [&#x27;=/A-B-c&#x27;, &#x27;D/=&#x27;]</span><span class="hljs-comment"># .lower()和upper()</span><span class="hljs-comment"># 将所有大写字母变成小写字母 将所有小写字母变成大写字母</span><span class="hljs-built_in">print</span>(info.lower())  <span class="hljs-comment"># =/a-b-c-d/=</span><span class="hljs-built_in">print</span>(info.upper())  <span class="hljs-comment"># =/A-B-C-D/=</span><span class="hljs-comment"># join()</span><span class="hljs-comment"># 将一个列表拼接为一个字符串，也可以指定字符串，当然这个列表里的值都必须是字符串</span>l = [<span class="hljs-string">&#x27;你&#x27;</span>, <span class="hljs-string">&#x27;好&#x27;</span>, <span class="hljs-string">&#x27;世&#x27;</span>, <span class="hljs-string">&#x27;界&#x27;</span>]<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &#x27;</span>.join(l))  <span class="hljs-comment"># 你 好 世 界</span><span class="hljs-comment"># replace()</span><span class="hljs-comment"># 将字符串内某些指定字符串替换掉，并生成一个新的字符串</span>l = <span class="hljs-string">&#x27;我好喜欢你，别分开好么？&#x27;</span><span class="hljs-built_in">print</span>(l.replace(<span class="hljs-string">&#x27;好&#x27;</span>, <span class="hljs-string">&#x27;好不&#x27;</span>))  <span class="hljs-comment"># 我好不喜欢你，别分开好不么？</span><span class="hljs-comment"># 当然也可以指定替换的 次数</span><span class="hljs-built_in">print</span>(l.replace(<span class="hljs-string">&#x27;好&#x27;</span>, <span class="hljs-string">&#x27;好不&#x27;</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># 我好不喜欢你，别分开好么？</span></code></pre></div><h3 id="字符串的格式化输出"><a href="#字符串的格式化输出" class="headerlink" title="字符串的格式化输出"></a>字符串的格式化输出</h3><h4 id="s格式化输出"><a href="#s格式化输出" class="headerlink" title="%s格式化输出"></a>%s格式化输出</h4><p>例如，我们要显示My name is XXX，I am from XXX，在XXX的位置分别显示姓名和住址。</p><p>代码如下<strong>（按位置传值）</strong></p><img src="/post/32119/Image.png" class="" title="This is a picture"><p>右边的值是按照位置一一对应传递给左边的，少一个&#x2F;多一个都会报错，用法就是这样，可以自己试试看当然我们还可以不按照位置传值</p><p>代码如下<strong>（按字典传值）</strong></p><img src="/post/32119/Image(2).png" class="" title="This is a picture"><p>这时候<strong>原字符串内的%s就要被替换为%(key)s</strong>这样才能完成格式化。由于其是不按位置传值的，所以后面的name，hometown顺序可以更换。</p><h4 id="d格式化输出"><a href="#d格式化输出" class="headerlink" title="%d格式化输出"></a>%d格式化输出</h4><p>%d可以传整型，浮点型的值，会被转换成字符串型，但是传入字符串型就会直接报错。</p><p><strong>::总结：%s可以传任何类型的值进去，其都会被转换成字符串型::</strong></p><h4 id="format格式化输出"><a href="#format格式化输出" class="headerlink" title="format格式化输出"></a>format格式化输出</h4><p>format是Python提供的内置格式化字符串的函数。</p><img src="/post/32119/Image(3).png" class="" title="This is a picture"><p>当我们在{}内不提供任何内容的时候，是按照传入参数的索引作为位置替换的。当然我们也可以在大括号内添加索引号，{1}就会被填充为Guangzhou</p><p>当然也可以采用key:value的格式来填充</p><img src="/post/32119/Image(4).png" class="" title="This is a picture"><h4 id="f格式化字符串"><a href="#f格式化字符串" class="headerlink" title="f格式化字符串"></a>f格式化字符串</h4><p>直接来看一个例子</p><img src="/post/32119/Image(5).png" class="" title="This is a picture"><p>在字符串前面加一个f，并且将要替换的位置用{变量名}替换即可。</p><h2 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h2><p>首先我们来了解一下，如何生成一个列表，你可能会疑惑，这个问题我们在第一章已经解决了。还记得我们第一章是怎么解决的么？</p><div class="code-wrapper"><pre><code class="hljs python">hobbies = [<span class="hljs-string">&#x27;打羽毛球&#x27;</span>,<span class="hljs-string">&#x27;可乐&#x27;</span>,<span class="hljs-string">&#x27;读书&#x27;</span>]</code></pre></div><p>我们直接给了hobbies一个列表，那这个列表是怎么被造出来的，其实这是list()的功能，还记得类型转换么？list()就是可以进行类型转换的，那么它可以把什么类型进行转换呢？？？🧐</p><p>答案是<strong>任何可迭代对象</strong>，list()可以把任何<strong>可迭代对象</strong>转换成list类型。</p><h3 id="列表的内置操作"><a href="#列表的内置操作" class="headerlink" title="列表的内置操作"></a>列表的内置操作</h3><p>首先，列表的内置操作有，::<strong>索引取值</strong>、切片、<strong>追加、插入、extend</strong>、长度、成员运算、<strong>删除、计数</strong>::</p><p>我们可以把字符串类比为一个列表，因此列表的很多内置操作和字符串都是大同小异的。上面加粗的是我们会讲的，其他类比字符串类型即可。</p><p><strong>索引取值：</strong>首先，字符串也可以索引取值，但是为什么我们还要在列表中也讲一遍，因为列表还可以 索引改值。因为<strong>列表是可变类型，字符串是不可变类型</strong>。就像下面一样。</p><div class="code-wrapper"><pre><code class="hljs python">l = [<span class="hljs-string">&#x27;李慧&#x27;</span>,<span class="hljs-string">&#x27;高启&#x27;</span>,<span class="hljs-string">&#x27;赵李&#x27;</span>]l[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;高启强&#x27;</span> * <span class="hljs-number">2</span><span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;李慧&#x27;, &#x27;高启强高启强&#x27;, &#x27;赵李&#x27;]</span><span class="hljs-comment"># 复习了一下字符串的操作，不知道还记不记得那个*的意思</span></code></pre></div><p><strong>追加：</strong>如果我们想要在索引3的位置增加一个“高纬”，那我们就要用到l.append(内容)</p><div class="code-wrapper"><pre><code class="hljs python">l = [<span class="hljs-string">&#x27;李慧&#x27;</span>,<span class="hljs-string">&#x27;高启&#x27;</span>,<span class="hljs-string">&#x27;赵李&#x27;</span>]l.append(<span class="hljs-string">&#x27;高纬&#x27;</span>)<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;李慧&#x27;, &#x27;高启&#x27;, &#x27;赵李&#x27;, &#x27;高纬&#x27;]</span></code></pre></div><p><strong>插入：</strong>如果我们要想在列表在第1号索引的位置，插入一个值，其他值往后移动。就要用到insert(索引值，内容）</p><div class="code-wrapper"><pre><code class="hljs python">l = [<span class="hljs-string">&#x27;李慧&#x27;</span>,<span class="hljs-string">&#x27;高启&#x27;</span>,<span class="hljs-string">&#x27;赵李&#x27;</span>]l.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;高纬&#x27;</span>)<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;李慧&#x27;, &#x27;高纬&#x27;, &#x27;高启&#x27;, &#x27;赵李&#x27;]</span></code></pre></div><p><strong>extend：</strong>如果我们有另外的一个列表我们想把两个列表合并，我们该使用extend(可迭代对象）</p><div class="code-wrapper"><pre><code class="hljs python">l = [<span class="hljs-string">&#x27;李慧&#x27;</span>,<span class="hljs-string">&#x27;高启&#x27;</span>,<span class="hljs-string">&#x27;赵李&#x27;</span>]l2 = [<span class="hljs-string">&#x27;赵高&#x27;</span>]l.extend(l2)<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;李慧&#x27;, &#x27;高启&#x27;, &#x27;赵李&#x27;, &#x27;赵高&#x27;]</span></code></pre></div><p><strong>删除：</strong>我们之前学过用del来解除一个变量和一个值的关系，现在如果我们要删除列表内的某个元素。就要用pop(索引值)【不传值默认删除最后一个】remove(元素)：可以删除指定的元素。</p><div class="code-wrapper"><pre><code class="hljs python">l = [<span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;高启&#x27;</span>, <span class="hljs-string">&#x27;赵李&#x27;</span>]<span class="hljs-keyword">del</span> l[<span class="hljs-number">0</span>]<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;高启&#x27;, &#x27;赵李&#x27;]</span>l = [<span class="hljs-string">&#x27;李慧&#x27;</span>,<span class="hljs-string">&#x27;高启&#x27;</span>,<span class="hljs-string">&#x27;赵李&#x27;</span>]l.pop(<span class="hljs-number">1</span>)<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;李慧&#x27;, &#x27;赵李&#x27;]</span>l = [<span class="hljs-string">&#x27;李慧&#x27;</span>,<span class="hljs-string">&#x27;高启&#x27;</span>,<span class="hljs-string">&#x27;赵李&#x27;</span>]l.remove(<span class="hljs-string">&#x27;李慧&#x27;</span>)<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;高启&#x27;, &#x27;赵李&#x27;]</span></code></pre></div><p><strong>其他操作：</strong></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># count(元素) 查找某个元素出现了几次</span>l = [<span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;高启&#x27;</span>, <span class="hljs-string">&#x27;赵李&#x27;</span>, <span class="hljs-string">&#x27;李慧&#x27;</span>]<span class="hljs-built_in">print</span>(l.count(<span class="hljs-string">&#x27;李慧&#x27;</span>))  <span class="hljs-comment"># 2</span><span class="hljs-comment"># index(元素) 查找某个元素的索引号，从左往右找，找到就停</span><span class="hljs-built_in">print</span>(l.index(<span class="hljs-string">&#x27;李慧&#x27;</span>))  <span class="hljs-comment"># 0</span><span class="hljs-comment"># clear() 清空某个列表</span>l.clear()<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># []</span><span class="hljs-comment"># reverse() 反转一个列表</span>l = [<span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;高启&#x27;</span>, <span class="hljs-string">&#x27;赵李&#x27;</span>, <span class="hljs-string">&#x27;李慧&#x27;</span>]l.reverse()<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;李慧&#x27;, &#x27;赵李&#x27;, &#x27;高启&#x27;, &#x27;李慧&#x27;]</span></code></pre></div><p><strong>排序：</strong>我们可以用sort()实现对列表的升序排序，如果传入reserve &#x3D; True就可以实现降序排序</p><div class="code-wrapper"><pre><code class="hljs python">l = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>]l.sort()<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;s&#x27;, &#x27;z&#x27;]</span>l.sort(reverse=<span class="hljs-literal">True</span>)<span class="hljs-built_in">print</span>(l)  <span class="hljs-comment"># [&#x27;z&#x27;, &#x27;s&#x27;, &#x27;m&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span></code></pre></div><h2 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h2><p>这是我们要学习的一个新的数据类型，元组就是 不可变的列表</p><div class="code-wrapper"><pre><code class="hljs python">tuples = (<span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;张明&#x27;</span>, <span class="hljs-string">&#x27;康熙&#x27;</span>, <span class="hljs-string">&#x27;鹿海&#x27;</span>)three = (<span class="hljs-string">&#x27;李慧&#x27;</span>,)<span class="hljs-comment"># 由于小括号的特殊性，导致元组只有一个元素的时候，就要加个逗号。</span><span class="hljs-comment"># 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</span><span class="hljs-built_in">print</span>(tuples)  <span class="hljs-comment"># (&#x27;李慧&#x27;, &#x27;张明&#x27;, &#x27;康熙&#x27;, &#x27;鹿海&#x27;)</span><span class="hljs-comment"># 可以把字符串看作一种特殊的元组</span><span class="hljs-built_in">print</span>(tuples + three)  <span class="hljs-comment"># (&#x27;李慧&#x27;, &#x27;张明&#x27;, &#x27;康熙&#x27;, &#x27;鹿海&#x27;, &#x27;李慧&#x27;)</span><span class="hljs-comment"># 元组的元素不可改变，但它可以包含可变的对象，比如list列表</span>tuplist = (<span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;张明&#x27;</span>, <span class="hljs-string">&#x27;康熙&#x27;</span>, <span class="hljs-string">&#x27;鹿海&#x27;</span>,[<span class="hljs-string">&#x27;张自成&#x27;</span>,<span class="hljs-string">&#x27;李自健&#x27;</span>])<span class="hljs-built_in">print</span>(tuplist)  <span class="hljs-comment"># (&#x27;李慧&#x27;, &#x27;张明&#x27;, &#x27;康熙&#x27;, &#x27;鹿海&#x27;, [&#x27;张自成&#x27;, &#x27;李自健&#x27;])</span><span class="hljs-comment"># 下面的语句是对 tuplist第3索引 的列表进行操作</span>tuplist[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;张自民&#x27;</span><span class="hljs-built_in">print</span>(tuplist)  <span class="hljs-comment"># (&#x27;李慧&#x27;, &#x27;张明&#x27;, &#x27;康熙&#x27;, &#x27;鹿海&#x27;, [&#x27;张自成&#x27;, &#x27;张自民&#x27;])</span></code></pre></div><p>那么既然可以包含可变的对象，那么元组到底不可变了什么呢？</p><p>不可变的是存的内存地址，还记得列表在内存的存储方式么</p><img src="/post/32119/Image(6).png" class="" title="This is a picture"><p>它不可变的，就是值“a”对应的内存地址等这些。</p><h4 id="元组和列表"><a href="#元组和列表" class="headerlink" title="元组和列表"></a>元组和列表</h4><p>元组是用来存储一组不变的值，那如果我们定义一个列表，我们不去改它，就让他在那里，不就好了么？元组存在的意义是什么呢？列表可以改也可以写。如果一组数据，只有读取的需求，而没有写的需求，那么当然是元组更加节省内存空间，当然，也没有那么省，所以，最好还是该使用元组的时候使用元组。</p><h3 id="元组的内置操作"><a href="#元组的内置操作" class="headerlink" title="元组的内置操作"></a>元组的内置操作</h3><p>由于元组的不可修改性质，我们元组有的操作只有**::索引取值、切片、统计长度、成员运算、循环以及index和count::**等。</p><p>自己去试试吧。</p><h2 id="字典类型"><a href="#字典类型" class="headerlink" title="字典类型"></a>字典类型</h2><p>我们之前说过字典类型的key只可以是字符串类型和数字类型，那么这两种类型都统称为“不可变类型”，那元组也可以作为字典的key。</p><h4 id="造一个字典-产生一个字典"><a href="#造一个字典-产生一个字典" class="headerlink" title="造一个字典&#x2F;产生一个字典"></a>造一个字典&#x2F;产生一个字典</h4><p>如何造一个字典呢？我们一开始在基本数据类型中使用的是<code>&#123;key : value, key : value&#125;</code>这样的格式来造出一个字典的，那这个字典是怎么被造出来的，其实这是 <code>dict()</code> 的功能。下面我们来介绍几种其他造字典的方法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 第一种 用dict来造一个字典</span>dic = <span class="hljs-built_in">dict</span>(&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;李慧&#x27;</span>,<span class="hljs-string">&#x27;home&#x27;</span>:<span class="hljs-string">&#x27;浙江&#x27;</span>&#125;)<span class="hljs-built_in">print</span>(dic)  <span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;李慧&#x27;, &#x27;home&#x27;: &#x27;浙江&#x27;&#125;</span><span class="hljs-comment"># 第二种 dict(变量名=值,变量名=值)的格式来创建字典</span>dic = <span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&#x27;李慧&#x27;</span>,home=<span class="hljs-string">&#x27;浙江&#x27;</span>)<span class="hljs-built_in">print</span>(dic)  <span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;李慧&#x27;, &#x27;home&#x27;: &#x27;浙江&#x27;&#125;</span><span class="hljs-comment"># 第三种formkeys 如果我们要初始化一个字典，将所有值设为None</span>keys = [<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;home&#x27;</span>]dic = &#123;&#125;.fromkeys(keys, <span class="hljs-literal">None</span>)<span class="hljs-built_in">print</span>(dic)  <span class="hljs-comment"># &#123;&#x27;name&#x27;: None, &#x27;home&#x27;: None&#125;</span></code></pre></div><h4 id="字典的类型转换"><a href="#字典的类型转换" class="headerlink" title="字典的类型转换"></a>字典的类型转换</h4><p>字典的类型转换有点不太一样，由于其特殊的key:value的性质，其<strong>传入的可迭代对象，必须是要成对出现</strong>的。</p><div class="code-wrapper"><pre><code class="hljs python">info = [[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;李慧&#x27;</span>],[<span class="hljs-string">&#x27;home&#x27;</span>,<span class="hljs-string">&#x27;浙江&#x27;</span>]]</code></pre></div><h4 id="字典的基本操作"><a href="#字典的基本操作" class="headerlink" title="字典的基本操作"></a>字典的基本操作</h4><p><strong>列表取值&#x2F;改值：</strong>这个和列表差不多，只是把索引变成了key。如果::字典的key不存在，是可以根据key来添加值的。::字典没有插入和增加值（insert和append）这是因为<strong>字典是无序的，列表是有序的。</strong></p><div class="code-wrapper"><pre><code class="hljs python">dic = &#123;&#125;dic[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;王慧&#x27;</span><span class="hljs-built_in">print</span>(dic)  <span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;王慧&#x27;&#125;</span></code></pre></div><p><strong>更安全的取值：</strong>我们之前学过字典的取值，是使用[key]来取值的，但是当我们取一个根本不存在的key，Python就会给我们报错了。get(key)的方法就是更安全的取值。</p><div class="code-wrapper"><pre><code class="hljs python">info = [[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;李慧&#x27;</span>],[<span class="hljs-string">&#x27;home&#x27;</span>,<span class="hljs-string">&#x27;浙江&#x27;</span>]]dic = <span class="hljs-built_in">dict</span>(info)<span class="hljs-built_in">print</span>(dic.get(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-comment"># None</span></code></pre></div><p>就像上面这样。</p><p><strong>删除值：</strong>首先通用的删除方法del，这个和列表的差不多。然后就是<code>pop，clear，popitem</code></p><div class="code-wrapper"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;home&#x27;</span>: <span class="hljs-string">&#x27;浙江&#x27;</span>&#125;<span class="hljs-keyword">del</span> dic[<span class="hljs-string">&#x27;name&#x27;</span>]<span class="hljs-built_in">print</span>(dic)  <span class="hljs-comment"># &#123;&#x27;home&#x27;: &#x27;浙江&#x27;&#125;</span>dic = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;home&#x27;</span>: <span class="hljs-string">&#x27;浙江&#x27;</span>&#125;<span class="hljs-built_in">print</span>(dic.pop(<span class="hljs-string">&#x27;name&#x27;</span>)) <span class="hljs-comment"># 李慧</span><span class="hljs-built_in">print</span>(dic)  <span class="hljs-comment"># &#123;&#x27;home&#x27;: &#x27;浙江&#x27;&#125;</span>dic = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;home&#x27;</span>: <span class="hljs-string">&#x27;浙江&#x27;</span>&#125;<span class="hljs-built_in">print</span>(dic.popitem())  <span class="hljs-comment"># (&#x27;home&#x27;, &#x27;浙江&#x27;)</span><span class="hljs-built_in">print</span>(dic) <span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;李慧&#x27;&#125;</span></code></pre></div><p>注意一下，<code>popitem</code>返回的是一个元组，它清除的字典的最后一个值（字典本身是无序的）这个最后，是根据其放入的先后顺序得到的，也就是最后放入的值，会被先删除。</p><p><strong>字典的内置方法：</strong><code>keys() values() items()</code> 迭代器</p><div class="code-wrapper"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;李慧&#x27;</span>, <span class="hljs-string">&#x27;home&#x27;</span>: <span class="hljs-string">&#x27;浙江&#x27;</span>&#125;<span class="hljs-built_in">print</span>(dic.keys())  <span class="hljs-comment"># dict_keys([&#x27;name&#x27;, &#x27;home&#x27;])</span><span class="hljs-built_in">print</span>(dic.values())  <span class="hljs-comment"># dict_values([&#x27;李慧&#x27;, &#x27;浙江&#x27;])</span><span class="hljs-built_in">print</span>(dic.items())  <span class="hljs-comment"># dict_items([(&#x27;name&#x27;, &#x27;李慧&#x27;), (&#x27;home&#x27;, &#x27;浙江&#x27;)])</span></code></pre></div><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>这是一个新的数据类型，它的作用并不是用来取值和存值的，它是用来做去重和关系运算的。集合可以存入任何<strong>不可变类型</strong>，那就说明，列表就是不能存入的。<strong>集合是不可以重复的</strong>，就算你定义的时候，写了多个但是还是只会存一个。集合是不能取值的，其本身是作为一个整体使用的，如果你使用索引去取值，就会报错。<strong>如果要取值就可以将集合转成list类型。</strong></p><p>可以使用<strong>大括号 { } 或者 set() 函数</strong>创建集合，::注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。::</p><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;abracadabra&#x27;</span>)b = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;alacazam&#x27;</span>)<span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># &#123;&#x27;a&#x27;, &#x27;r&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># &#123;&#x27;a&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;, &#x27;c&#x27;&#125;</span><span class="hljs-built_in">print</span>(a - b)     <span class="hljs-comment"># a 和 b 的差集</span><span class="hljs-built_in">print</span>(a | b)     <span class="hljs-comment"># a 和 b 的并集</span><span class="hljs-built_in">print</span>(a &amp; b)     <span class="hljs-comment"># a 和 b 的交集</span><span class="hljs-built_in">print</span>(a ^ b)     <span class="hljs-comment"># a 和 b 中不同时存在的元素</span></code></pre></div><p>你可以自己试试上面的方法，至于差集、并集、交集。你应该都知道，数学里有学过。</p><h1 id="至此，你已经学完了所有基本数据类型🎉🎉🎉"><a href="#至此，你已经学完了所有基本数据类型🎉🎉🎉" class="headerlink" title="至此，你已经学完了所有基本数据类型🎉🎉🎉"></a>至此，你已经学完了所有基本数据类型🎉🎉🎉</h1>]]></content>
    
    
    <categories>
      
      <category> Python教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/post/21513/"/>
    <url>/post/21513/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数引入"><a href="#函数引入" class="headerlink" title="函数引入"></a>函数引入</h2><p>如果你有其他编程语言的基础，对这个名称肯定不是很陌生。<strong>循环解决了一段代码多次使用的问题，而函数则解决了多处使用的问题</strong>。 举个例子，你要写一个求最大公约数的功能，然而你的代码中有两个地方要用到这个功能，那如果复制粘贴，你的<strong>代码</strong>就会显得很<strong>冗余</strong>，且如果后期要进行修改，要连着修改两处地方，<strong>可维护性&#x2F;可扩展性很差</strong>。同时，你的代码也会显得<strong>组织结构不清晰，可读性差</strong>。</p><p>那到底什么是函数呢？？？<strong>简单来说，函数就是具备某一功能的工具。</strong>那么如果我们要使用函数，就肯定要<strong>先定义，后调用。</strong></p><h2 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h2><p>来看一下函数定义的语法</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2.</span>..</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    文档注释</span><span class="hljs-string">    &quot;&quot;&quot;</span>    函数体    <span class="hljs-keyword">return</span> 返回值</code></pre></div><p><code>return 返回值</code> 可以不写，不写就是没有返回值，返回的就是None。</p><table><thead><tr><th><strong>内容</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>def关键字</td><td>必需</td></tr><tr><td>函数名</td><td>必需</td></tr><tr><td>参数</td><td>可选</td></tr><tr><td>()</td><td>必需</td></tr><tr><td>文档注释</td><td>可选，最好有</td></tr><tr><td>函数体</td><td>必需</td></tr><tr><td>return 返回值</td><td>可选，无返回None</td></tr></tbody></table><p>我们来看一个简单的函数示例</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rwprint</span>(<span class="hljs-params">text</span>):    <span class="hljs-built_in">print</span>(text)rwprint(<span class="hljs-string">&#x27;这是我的第一个函数&#x27;</span>)</code></pre></div><p>上面的这个 <code>rwprint()</code> 重写了print函数，虽然这个例子没有什么价值，但是可以让我们很好的理解函数的定义和调用。</p><p>函数，可以被分为两个阶段，第一个是<strong>定义阶段</strong>，第二个是<strong>调用阶段</strong>。我们往详细讲讲函数的定义和调用。<strong>（往内存方向）</strong>到底在定义函数和调用函数的时候发生了什么。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这是我的第一个函数&#x27;</span>)<span class="hljs-comment"># 首先在函数定义阶段，内存里存入了子代码，函数名指向了一个内存地址</span><span class="hljs-comment"># 因此当我们打印&lt;函数名&gt;的时候</span><span class="hljs-built_in">print</span>(func)  <span class="hljs-comment"># &lt;function func at 0x7fcf4b9bbf70&gt;</span><span class="hljs-comment"># 如果加上了()就是执行子代码。</span><span class="hljs-built_in">print</span>(func()) <span class="hljs-comment"># None</span></code></pre></div><p>定义完函数后，将子代码存入到一片内存空间，然后将内存空间的地址绑定给函数名。我们可以通过type来查看它的类型：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(func))<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(func()))</code></pre></div><p>你肯定疑惑两段代码差不多，只是一组括号的差别，这有什么区别呢？第一段代码的结果是肯定的</p><p><code>&lt;class &#39;function&#39;&gt;</code>  是函数的类型。第二段代码的类型是代码返回值的类型，举个例子</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>():    a = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> a<span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():    a = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(a)<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(func1()))  <span class="hljs-comment"># &lt;class &#x27;int&#x27;&gt;</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(func2()))  <span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span></code></pre></div><p>这两段代码在函数体上面没有任何分别，只是我们返回一个a的值。但是在return中我们把func2的0进行了类型转换，使得其返回一个字符串类型的0。</p><p><del>我们究其一生，都在问询着那个最后的结果；就像函数一样，算到内存溢出，磁盘停转，也终是为了得到那个return。但是无论我们的得到的是何结果，我们付出的却都是努力；就像最后函数的结果是不定的，但是其本身还是那个函数。</del></p><p>我们说了，函数的使用分为定义和调用的阶段，这两个过程是分开的。举个例子</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;成功调用func2 结果是 -&gt; &#x27;</span> + func2())<span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():    a = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(a)func1()</code></pre></div><p>我们在func1中就写好了func2的调用，想想那么这个应该是会报错的吧，func2当时还没被定义。但是结果是不会报错的，能正常运行。我们可以把函数的定义理解为一个存的过程，函数的调用理解为取的过程。<strong>定义的过程就是存入子代码到内存空间，将内存空间的地址绑定给函数名，只会检查语法错误。</strong>下面的那种用法就是错误用法。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;成功调用func2 结果是 -&gt; &#x27;</span> + func2())func1()<span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():    a = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(a)</code></pre></div><p>我们还在func2还没被定义的时候，就通过func1去执行代码，这样肯定是不可行的，因此报错了。</p><h2 id="有参函数"><a href="#有参函数" class="headerlink" title="有参函数"></a>有参函数</h2><p>其实我们之前已经接触过有参函数，包括像<code>print()、open()</code> 等。</p><p>这些是Python内置的函数，当然正是因为Python不可能给我们写好所有函数，不可能满足我们所有人各种各样的需求，所以才会有<strong>自定义函数</strong>的出现。</p><p>我们来举个例子，接下来我们要带你用之前学习过的知识，来写一个自动生成指定文件内容的函数。</p><blockquote><p>具体需求：传入两个参数，一个是文件名，一个是数据。当我们输入一个不存在的文件名的时候，会自动创建文件，如果文件存在，那么将会写入数据<strong>（注意数据是追加的）</strong>。</p></blockquote><p>简单分析一下需求，这大概用到的是<strong>文件操作</strong>相关的知识。数据是追加的，那open用到的模式是a，写入的是文本，那就是t，那么所用到的模式是at。来看代码</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">filewrite</span>(<span class="hljs-params">filename, data</span>):    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-keyword">as</span> f:        f.write(data)filewrite(<span class="hljs-string">&#x27;word.txt&#x27;</span>, <span class="hljs-string">&#x27;swf&#x27;</span>)</code></pre></div><p>代码就是上面这样，我们分析一下有参函数，<code>filename</code>对应了<code>’word.txt’</code> <code>data</code>对应了<code>‘swf’</code></p><p>也就是说在函数中，执行了两个赋值操作<code>filename = ‘word.txt‘</code> 和 <code>date=‘swf’</code></p><p>其实实现上面的需求并不难，主要是依靠以前学过的知识，<strong>函数只是套上了一个外壳而已。方便我们去调用。</strong></p><p>如果你之前有学习过其他编程语言，那你肯定知道<strong>形参和实参</strong></p><p><strong>在参数表中的参数和函数体内使用的参数，就是形参，或者说在定义函数阶段的参数是形参，而在函数调用阶段中则使用的是实参。</strong></p><h2 id="无参函数"><a href="#无参函数" class="headerlink" title="无参函数"></a>无参函数</h2><p>如果我们要做的函数是依靠用户输入来实现的，或者是仅仅对现有功能的一个打包，那么我们就可以使用无参函数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">filewrite</span>():    filename = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入文件名 &gt;&gt;&gt; &#x27;</span>)    data = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入要写入的数据 &gt;&gt;&gt; &#x27;</span>)    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-keyword">as</span> f:        f.write(data)</code></pre></div><h2 id="如何写一个函数"><a href="#如何写一个函数" class="headerlink" title="如何写一个函数"></a>如何写一个函数</h2><p>可能到目前为止，你还不是很会熟练的写函数。那么我们来教你一个方法。还是以上面的例子为例。</p><p>首先是写一个最基本的功能，就像下面一样</p><div class="code-wrapper"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;word.txt&#x27;</span>data = <span class="hljs-string">&#x27;swj&#x27;</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-keyword">as</span> f:    f.write(data)</code></pre></div><p>接下来，套上函数的外壳，将整段代码缩进。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">filewrite</span>():    filename = <span class="hljs-string">&#x27;word.txt&#x27;</span>    data = <span class="hljs-string">&#x27;swj&#x27;</span>     <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-keyword">as</span> f:        f.write(data)</code></pre></div><p>最后看我们是否把这段代码写死了，就是看它是否能在不同的地方被使用。很明显上面的代码并不能。所以我们把<code>filename和data</code> 移动到参数表。结果如下。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">filewrite</span>(<span class="hljs-params">filename, data</span>):    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-keyword">as</span> f:        f.write(data)</code></pre></div><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>还是之前的例子，来写一个自动生成指定文件内容的函数。<strong>只是有一点点小改动。</strong></p><blockquote><p>具体需求：传入两个参数，一个是文件名，一个是数据。当我们输入一个不存在的文件名的时候，会自动创建文件，如果文件存在，那么将会写入数据<strong>（注意数据是追加的）</strong>。写入数据后返回当前文件内的<strong>所有数据</strong>。</p></blockquote><p>我们只是增加了一个功能，返回当前文件内的所有数据，那么我们还要为此增加一个读取文件内容的功能。直接看结果吧。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">filewriter</span>(<span class="hljs-params">filename,data</span>):    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-keyword">as</span> f:        f.write(data)    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&#x27;rt&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:        res = f.read()    <span class="hljs-keyword">return</span> res<span class="hljs-built_in">print</span>(filewriter(<span class="hljs-string">&#x27;word.txt&#x27;</span>,<span class="hljs-string">&#x27;2222321&#x27;</span>))</code></pre></div><p>我们为其增加了一段读取文件内容的代码，并将结果赋值给res，返回这个res，当我们调用这个函数的时候，就会返回给我们读取到文件的内容。当然这个返回值的类型是和我们返回数据的类型一致的。</p><p><strong>当函数运行到return的时候，就会立刻结束函数的运行，因此return是函数结束的标志。</strong></p><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p>位置参数被分为<strong>位置形参</strong>和<strong>位置实参</strong></p><p>位置形参：在定义函数的阶段，从左往右依次定义的形参，<strong>必须传值给位置形参</strong>，且不能多也不能少。</p><p>位置实参：在调用函数的阶段，从左往右依次赋值给对应的形参。</p><p>看下面的一个例子就可以说明<strong>位置形参</strong>和<strong>位置实参</strong>的关系。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, z</span>):    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;func的结果 x = <span class="hljs-subst">&#123;x&#125;</span> y = <span class="hljs-subst">&#123;y&#125;</span> z = <span class="hljs-subst">&#123;z&#125;</span>&#x27;</span>)func(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># func的结果 x = 1 y = 3 z = 2</span></code></pre></div><h2 id="关键字参数（关键字形参）"><a href="#关键字参数（关键字形参）" class="headerlink" title="关键字参数（关键字形参）"></a>关键字参数（关键字形参）</h2><p>除了使用位置参数，我们还可以不根据位置参数来传值。就是使用关键字参数。我们可以用形如<code>y=3</code> 这样的参数指定方式进行传参。<strong>（key &#x3D; value）</strong></p><p>当然<strong>key必须是在函数定义阶段中参数表</strong>中已经存在的了。否则就会产生错误。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, z</span>):    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;func的结果 x = <span class="hljs-subst">&#123;x&#125;</span> y = <span class="hljs-subst">&#123;y&#125;</span> z = <span class="hljs-subst">&#123;z&#125;</span>&#x27;</span>)func(y=<span class="hljs-number">3</span>, x=<span class="hljs-number">1</span>, z=<span class="hljs-number">2</span>)  <span class="hljs-comment"># func的结果 x = 1 y = 3 z = 2</span></code></pre></div><p>关键字参数和位置参数的混用必须要遵守一个原则<strong>“位置参数必须在关键字参数之前”</strong></p><div class="code-wrapper"><pre><code class="hljs python">func(<span class="hljs-number">3</span>, y=<span class="hljs-number">1</span>, z=<span class="hljs-number">2</span>)  <span class="hljs-comment"># func的结果 x = 3 y = 1 z = 2</span></code></pre></div><h2 id="默认参数（默认形参）"><a href="#默认参数（默认形参）" class="headerlink" title="默认参数（默认形参）"></a>默认参数（默认形参）</h2><p>默认形参，就是在函数的定义阶段，给函数的形参一个默认值，这样在函数的调用阶段，我们可以不用给实参，而是使用默认参数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, z=<span class="hljs-number">2</span></span>):    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;func的结果 x = <span class="hljs-subst">&#123;x&#125;</span> y = <span class="hljs-subst">&#123;y&#125;</span> z = <span class="hljs-subst">&#123;z&#125;</span>&#x27;</span>)func(<span class="hljs-number">3</span>, y=<span class="hljs-number">1</span>, z=<span class="hljs-number">2</span>)  <span class="hljs-comment"># func的结果 x = 3 y = 1 z = 2</span>func(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># func的结果 x = 3 y = 1 z = 2</span>func(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>)  <span class="hljs-comment"># func的结果 x = 3 y = 1 z = 9</span></code></pre></div><p>当我们使用默认参数的时候，当我们不给参数的时候，就会使用默认值，就像第二个函数调用一样，我们并没有给函数传入z的值，但是函数默认输出的就是2，并且也没有报错，而像第三个函数调用一样，z的值就会变成9</p><p>一个语法原则<strong>“默认形参必须放在位置形参后面”</strong></p><p><strong>“默认参数的值是在函数定义阶段被赋值的。”</strong>这个怎么理解呢？我们可以写一个函数来证明。</p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-number">2</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">x,y=a</span>):    <span class="hljs-built_in">print</span>(x,y)a = <span class="hljs-number">3</span>func1(<span class="hljs-number">2</span>)</code></pre></div><p>在这段代码中，a的初值是2，“y&#x3D;a”和“y&#x3D;2”等价，修改a的值，可以想象一下输出结果。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">2</span> <span class="hljs-number">2</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre></div><p>那么在内存中到底发生了什么，y&#x3D;a将a的内存地址给了y，但是a所指向的内存地址改变于是就会出现a的值改变了，但是函数内的值不会改变。但是如果a换成列表呢？</p><div class="code-wrapper"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">x, y=a</span>):    <span class="hljs-built_in">print</span>(x, y)a.append(<span class="hljs-number">3</span>)func1(<span class="hljs-number">2</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">2</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">2</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</code></pre></div><p>为什么呢？因为列表是可变类型，y的默认值指向了一个列表的内存地址（可以去看“变量和基本数据类型”里“列表在内存中的存储方式”）你就懂了，当我们修改或者增加列表的值，都是会改变的。</p><h2 id="可变长度的参数"><a href="#可变长度的参数" class="headerlink" title="可变长度的参数"></a>可变长度的参数</h2><p>指的是在调用函数时，传入的实参的个数是不固定的。而位置参数传入的参数是一个也不能多一个也不能少的。固定一个位置形参或者默认形参。我们学过两种实参，分别是<strong>关键字实参和位置实参。</strong>那分别对应的就有<strong>可变长度的位置实参和可变长度的关键字实参。</strong></p><p>那么我们怎么接收一个可变长度的位置实参呢？？很简单只需要在参数表中加入*</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">*args</span>):    <span class="hljs-built_in">print</span>(args)  <span class="hljs-comment"># (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(args))  <span class="hljs-comment"># &lt;class &#x27;tuple&#x27;&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category> Python教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量和基本数据类型</title>
    <link href="/post/40389/"/>
    <url>/post/40389/</url>
    
    <content type="html"><![CDATA[<h1 id="变量和基本数据类型"><a href="#变量和基本数据类型" class="headerlink" title="变量和基本数据类型"></a>变量和基本数据类型</h1><h2 id="变量与内存"><a href="#变量与内存" class="headerlink" title="变量与内存"></a>变量与内存</h2><p><strong>在一个变量被赋值时，Python将会向内存申请一块内存空间来存放新的值，只要是赋值操作，产生新值都会新申请一块内存空间</strong>。那么我们要用一个变量，申请一个内存空间，这个问题不大，但是内存是有限的，我们不可能无限制申请，那我们申请的变量但是不用的变量，就要考虑释放内存，这个操作就是内存管理。内存管理是个很复杂的问题，但是Python为我们做了一个机制。</p><p><strong>::Python中还有“垃圾回收机制”，当一个内存，没有任何一个变量指向这个内存，那么它就会被回收::</strong></p><p><strong>只要申请新的内存空间其内存地址就会不同，id也会不同。</strong>::可以通过<code>id(变量名)</code>来查看变量的id::</p><p>::id值不等同于内存地址，但是id值是由内存地址转换（运算）来的::可以说 <strong>::id值是内存地址的映射::</strong></p><p>但是来看一个反例，我们来看一个代码👀</p><img src="/post/40389/Image.png" class="" title="This is a picture"><p>是不是觉得被骗了，按理说，我们新赋值一个变量，我们的id就会改变，但是为什么a和b的id都是一样的，这就是<strong>小整数池</strong>的概念。</p><h2 id="小整数池"><a href="#小整数池" class="headerlink" title="小整数池"></a>小整数池</h2><p>首先，无论是<strong>往内存里放数据还是取数据，都是IO操作</strong>，计算机三大核心硬件（CPU，内存，硬盘）中，CPU的运行速度最快，内存其次，硬盘最慢；一旦你的程序里有了IO操作，那么就会拖慢CPU的运行速度，因此Python就做了一步优化，可以避免重复使用相同的值，而重复申请内存空间所带来的效率问题，Python解释器，会在启动的那一刻，创建出小整数池。<strong>其范围是-5～256</strong>，这些数字在使用时，不会申请新的内存空间，并且不会被 <strong>垃圾回收机制</strong> 回收。</p><p>我们可以来验证一下小整数池。</p><img src="/post/40389/Image(2).png" class="" title="This is a picture"><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>垃圾回收机制下有三个工作模块，<strong>引用计数机制，标记清除机制，分代回收机制</strong>。</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>当一个变量值被赋值给一个变量名时，那么这个变量值就会 引用计数+1，当我们使用<code>del 变量名</code> 清除了某一变量和对应值的绑定关系，或者同一个变量被赋予一个新值的时候，原变量绑定的值就会 引用计数-1 （这里还有其他变量和这个值绑定的情况）</p><p>我们来看一下上面的两种情况。由于一些代码编辑器会对Python优化，其得到的值就会不准确，这里我们使用Python编译器查看结果，在此之前，我们要使用一个包sys<strong>（使用<code>import sys</code>导入包)</strong></p><p>使用<code>sys.getrefcount(变量)</code> 来查看变量当前的引用计数，但是<strong>实际值是要-1</strong>的，包括了调用这个函数的临时计数。</p><img src="/post/40389/Image(3).png" class="" title="This is a picture"><p>因此“张xx”这个值将会被内存回收释放。</p><p>但是，垃圾回收机制只依靠引用计数是会产生问题的，因为有一些方法会欺骗到引用计数。</p><p>例如我们来看一个例子（循环引用）</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sysl1 = [<span class="hljs-string">&#x27;你&#x27;</span>, <span class="hljs-string">&#x27;是&#x27;</span>]l2 = [<span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-string">&#x27;你&#x27;</span>]<span class="hljs-comment"># 接下来我们在l1的末尾，加上l2</span>l1.append(l2)<span class="hljs-built_in">print</span>(l1)  <span class="hljs-comment"># 内存中，2号索引放的就是l2的内存地址</span><span class="hljs-comment"># 在l2的末尾加上l1</span>l2.append(l1)<span class="hljs-built_in">print</span>(l2)  <span class="hljs-comment"># 内存中，2号索引放的就是l1的内存地址</span><span class="hljs-comment"># 上面这番操作后，我们的l1和l2就形成了你中有我，我中有你的关系</span><span class="hljs-comment"># 这两个列表存在相互引用的关系，这就是循环引用</span><span class="hljs-comment"># 我们来看它们的引用计数</span><span class="hljs-built_in">print</span>(sys.getrefcount(l1) - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 2 一个是变量l1 一个是列表l2</span><span class="hljs-built_in">print</span>(sys.getrefcount(l2) - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 2 一个是变量l2 一个是列表l1</span><span class="hljs-comment"># 引用计数都是2次，于是我们再做一个操作</span><span class="hljs-keyword">del</span> l1<span class="hljs-keyword">del</span> l2<span class="hljs-comment"># 我们将这两个变量捆绑的关系取消，也就是说明，我们再也无法通过l1，l2访问到这个两个列表了</span><span class="hljs-comment"># 它们的引用计数-1了，但是他们之间列表的相互引用还存在，这就会导致这片内存不会被 垃圾回收机制 回收</span></code></pre></div><p>所以只靠引用计数是不行的，我们继续了解 垃圾回收机制 的第二解决方案</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>在将标记清除之前，我们先来了解一下变量名在内存的存储方式，首先毫无疑问，变量名肯定也是存在内存里的</p><div class="code-wrapper"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;张xx&#x27;</span></code></pre></div><p>我们来看它在内存中是怎么样的</p><img src="/post/40389/Image(4).png" class="" title="This is a picture"><p>可以看到，一个是栈区，专门用来存放变量名的，一个是堆区，专门用来存放变量值的，当我们赋值变量的时候，会在堆区开辟一片空间存放“张xx”，在栈区存放变量名name，两者形成引用关系，当堆区的变量被清除的时候，对应栈区的变量名也会被清除。</p><p>那么我们来看看循环引用在内存中的示意图</p><img src="/post/40389/Image(5).png" class="" title="This is a picture"><p>我用了红色的线表示间接引用，当我们执行<code>del l1</code> 的时候l1和内存地址0x0000001的绑定关系就解除了，执行<code>del l2</code> 也是相同的道理。我们无法通过任何变量访问到这两个内存空间，这时候这两块内存就泄露了。因而标记清除就出现了。</p><p>标记清除会在你内存空间不够用的时候，暂停程序，<strong>扫描栈区，不管是通过栈区能够直接引用或者间接引用到的，都标记为存活状态，一旦发现有栈区引用不到的值，都标记为死亡状态</strong>，只要我们一个变量无法使用直接引用引用到了，那么标记清除就会把它标记为垃圾，然后回收。</p><h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>由于引用计数在计数的时候，要将所有内存扫描一遍，这样的效率实在太低，我们来形象的说一下</p><img src="/post/40389/Image(6).png" class="" title="This is a picture"><p>我们刚开学的时候，老师肯定会检查作业，第一天，老师肯定会全部检查一遍，那些不做作业的同学，肯定就是垃圾了，然后我们每一次完成作业的，老师都标记🌸，比如当集齐5个🌸，就会被标记为良好的同学，这些同学检查作业的频次就会变成一个星期一次，又比如集齐10个🌸，就会被标记为优秀的同学，检查作业的频次就会变成一个月一次，这样看来，我们检查频次是在依次降低的。这样可以大大解决引用计数的效率问题。</p><h2 id="基础算术运算符"><a href="#基础算术运算符" class="headerlink" title="基础算术运算符"></a>基础算术运算符</h2><div class="code-wrapper"><pre><code class="hljs python">Python中基础的算术运算符如下a = <span class="hljs-number">13</span>b = <span class="hljs-number">3</span>c = a + b  <span class="hljs-comment"># 加</span>c = a - b  <span class="hljs-comment"># 减</span>c = a * b  <span class="hljs-comment"># 乘</span>c = a / b  <span class="hljs-comment"># 除法 得到一个浮点数</span>c = a // b  <span class="hljs-comment"># 除法 得到一个整数</span>c = a % b  <span class="hljs-comment"># 取余数</span>c = a ** b  <span class="hljs-comment"># 乘方</span></code></pre></div><h2 id="基础比较运算符"><a href="#基础比较运算符" class="headerlink" title="基础比较运算符"></a>基础比较运算符</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 比较运算符 == != &gt; &lt; &lt;= &gt;=</span><span class="hljs-comment"># 比较的结果是 True 和 False 其中的一个</span><span class="hljs-comment"># 注意 = 是赋值，== 才是表示等于</span><span class="hljs-comment"># 举个例子</span></code></pre></div><h3 id="基础逻辑运算符"><a href="#基础逻辑运算符" class="headerlink" title="基础逻辑运算符"></a>基础逻辑运算符</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 逻辑运算符 not and or</span><span class="hljs-comment"># 在程序中 会遇到很多很多的条件 到时候可能不只是一个条件可以解决的 所以就有了逻辑运算符</span><span class="hljs-comment"># not（非）and（与） or（或）</span><span class="hljs-comment"># 要记住这三个的优先级 是先not 然后是and 最后是or 可以记为NAO</span><span class="hljs-comment"># 我们前面不是说过么 True 是 1 False 是 0</span><span class="hljs-comment"># not的作用是逻辑取反</span><span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> <span class="hljs-literal">True</span>)  <span class="hljs-comment"># False</span><span class="hljs-comment"># and的作用是 与 我们看一张表格吧😏（这个表格叫真值表）</span><span class="hljs-comment"># A     B</span><span class="hljs-comment"># 1 and 1 结果是 1</span><span class="hljs-comment"># 1 and 0 结果是 0</span><span class="hljs-comment"># 0 and 1 结果是 0</span><span class="hljs-comment"># 0 and 0 结果是 0</span><span class="hljs-comment"># 懂了么 只有当两个条件同时满足才会出 1</span><span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span>)  <span class="hljs-comment"># False</span><span class="hljs-comment"># or的作用是 或 我们还是来看真值表</span><span class="hljs-comment"># A     B</span><span class="hljs-comment"># 1 and 1 结果是 1</span><span class="hljs-comment"># 1 and 0 结果是 1</span><span class="hljs-comment"># 0 and 1 结果是 1</span><span class="hljs-comment"># 0 and 0 结果是 0</span><span class="hljs-comment"># 只要两个条件中的 其中一个 满足了 就可以出 1</span><span class="hljs-comment"># 是不是还是挺好理解的 🤩</span><span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span>)  <span class="hljs-comment"># True</span></code></pre></div><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 赋值运算符 = += -= *= /= //= %= **=</span><span class="hljs-comment"># 其实你最先接触到的赋值符号就是 =</span><span class="hljs-comment"># 赋值运算符就是算术运算符加个等号 就可以了</span>a = <span class="hljs-number">11</span>a += <span class="hljs-number">1</span>  <span class="hljs-comment"># 等价于 a = a + 1</span><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 12</span><span class="hljs-comment"># 那么其他的赋值运算符就是同理的 可以试试看</span></code></pre></div><hr><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>首先，在Python中，并没有所谓的数字类型，数字类型被分为了 <strong>整型（int）和 浮点型（float）</strong></p><p>整型和浮点型是可以做算术操作的，其<strong>操作的结果类型是 浮点型</strong></p><img src="/post/40389/Image(7).png" class="" title="This is a picture"><p>当然还可以做比较操作，结果就是 布尔类型的。</p><p>🤔这里有一个问题，有待考虑。就是在计算机中，都是使用二进制表示的，那么True就可以用1表示 False就可以用0表示就是“非黑即白，不是True就是False”，以也有人认为<strong>布尔类型</strong>也应该被归类到<strong>数字类型</strong>中。</p><img src="/post/40389/Image(8).png" class="" title="This is a picture"><hr><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串可以使用单引号，双引号，三引号这都是可以的。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 字符串类型</span>a = <span class="hljs-string">&#x27;Python&#x27;</span>b = <span class="hljs-string">&quot;Python&quot;</span>c = <span class="hljs-string">&quot;&quot;&quot;Python&quot;&quot;&quot;</span> <span class="hljs-comment"># 这里的三引号并不是注释，当三引号的被给了一个变量，这个就会变成一个字符串</span></code></pre></div><p>那么，如果我们有一个需求，我们要打出“一起‘玩’Python”那么如果我们这样打</p><img src="/post/40389/Image(9).png" class="" title="This is a picture"><p>就出现了红色波浪线，这是因为，引号是成对出现的，那么那个“玩”所处的位置就很尴尬了。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 我们可以这样做</span><span class="hljs-comment"># 在双引号内套上一个单引号，或者在单引号内套上双引号，这些都是被允许的</span><span class="hljs-comment"># 还有就是在引号前面加上\，表示转义，这样就可以正常显示了。</span>a = <span class="hljs-string">&quot;一起&#x27;玩&#x27;Python&quot;</span>a = <span class="hljs-string">&#x27;一起&quot;玩&quot;Python&#x27;</span>a = <span class="hljs-string">&#x27;一起\&#x27;玩\&#x27;Python&#x27;</span></code></pre></div><p>字符串是可以相加的，我们使用“+”可以将字符串连接起来。仅仅是字符串和字符串才能相加。字符串和数字是不能相加，但是可以相乘。举个例子，*** 相当于将字符串重复数次**。</p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;人入&#x27;</span><span class="hljs-built_in">print</span>(a*<span class="hljs-number">5</span>) <span class="hljs-comment"># 人入人入人入人入人入</span></code></pre></div><hr><h2 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h2><p>前面的数字类型和字符串类型，都只能存一个值，但是如果我们的一个值想要包含多个信息，并且这些信息都可以被取到，那我们该使用什么类型呢？举个例子，比如我们想要保存一个人的爱好，应该使用字符串类型，就像下面这样</p><div class="code-wrapper"><pre><code class="hljs python">hobbies = <span class="hljs-string">&#x27;羽毛球，可乐，读书&#x27;</span></code></pre></div><p>这样也可以描述一个人的爱好，但是当我们想得到爱好的第二个值的时候，就没有办法了，这时候列表的概念就出现了，我们将这三个信息，放在一张表内，用索引和内容相互对应</p><table><thead><tr><th><strong>索引</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td>0</td><td>羽毛球</td></tr><tr><td>1</td><td>可乐</td></tr><tr><td>2</td><td>读书</td></tr></tbody></table><p>那比如我们想要拿到第二个爱好，是不是只要根据索引，就可以找到对应的值了，那么我们在Python中就要这样声明</p><div class="code-wrapper"><pre><code class="hljs python">hobbies = [<span class="hljs-string">&#x27;打羽毛球&#x27;</span>,<span class="hljs-string">&#x27;可乐&#x27;</span>,<span class="hljs-string">&#x27;读书&#x27;</span>]<span class="hljs-comment"># 如果想要得到第二个爱好只需要</span><span class="hljs-built_in">print</span>(hobbies[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 可乐</span></code></pre></div><p><strong>注意，在Python中，索引的开始是0，我们想要调用列表，需要 变量名[索引] 得到内容</strong></p><p>列表内还可以存放其他的类型，我们可以在列表里放数字类型，字符类型，当然列表也是可以嵌套的</p><p>比如，我们要一个persons列表，存每个人的信息（包括姓名，年龄，爱好）那么我们该如何声明？</p><div class="code-wrapper"><pre><code class="hljs python">persons = [[<span class="hljs-string">&#x27;张xx&#x27;</span>, <span class="hljs-number">23</span>, [<span class="hljs-string">&#x27;唱歌&#x27;</span>, <span class="hljs-string">&#x27;羽毛球&#x27;</span>, <span class="hljs-string">&#x27;篮球&#x27;</span>]], [<span class="hljs-string">&#x27;李xx&#x27;</span>, <span class="hljs-number">28</span>, [<span class="hljs-string">&#x27;打太极&#x27;</span>, <span class="hljs-string">&#x27;唱歌&#x27;</span>, <span class="hljs-string">&#x27;篮球&#x27;</span>]]]<span class="hljs-comment"># 实在不太会编名字</span><span class="hljs-comment"># 如果我们想要得到张xx的所有信息</span><span class="hljs-built_in">print</span>(persons[<span class="hljs-number">0</span>])  <span class="hljs-comment"># [&#x27;张xx&#x27;, 23, [&#x27;唱歌&#x27;, &#x27;羽毛球&#x27;, &#x27;篮球&#x27;]]</span><span class="hljs-comment"># 那比如我们想得到李xx的第二个爱好，我们应该</span><span class="hljs-built_in">print</span>(persons[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]) <span class="hljs-comment"># 唱歌</span><span class="hljs-comment"># 逐层嵌套，我们就用索引逐层去取</span></code></pre></div><p><strong>列表可以相当于其他编程语言中的 数组</strong></p><h2 id="字典类型"><a href="#字典类型" class="headerlink" title="字典类型"></a>字典类型</h2><p>列表类型只能通过 索引 去描述一个事物的位置。但如果我们要存张xx的身高，体重，薪水。那么虽然列表也可以存储，但是我们要去数索引，这是不是很麻烦。</p><p>于是我们引入 key对应值 这个key通常为字符串类型，这样就赋予了其有描述性功能。我们按照以下方式定义</p><div class="code-wrapper"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张xx&#x27;</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">167</span>, <span class="hljs-string">&#x27;薪水&#x27;</span>: <span class="hljs-number">18000</span>&#125;</code></pre></div><p>我们定义了一个字典，其结构就像下面一样。</p><table><thead><tr><th><strong>key</strong></th><th><strong>值</strong></th></tr></thead><tbody><tr><td>name</td><td>张xx</td></tr><tr><td>height</td><td>167</td></tr><tr><td>薪水</td><td>18000</td></tr></tbody></table><p>我们要获取字典的值，就用 <strong>变量名[key]</strong>  去获取这个字典里某个key对应的值。</p><p>这个key也可以是数字类型的，那么我们的引用格式就是和列表一样了</p><img src="/post/40389/Image(10).png" class="" title="This is a picture"><p>同样字典里可以放列表，列表里也可以放字典。其取值方式也大同小异，遇到列表就索引取，遇到字典就key取。</p><h2 id="布尔类型和None"><a href="#布尔类型和None" class="headerlink" title="布尔类型和None"></a>布尔类型和None</h2><p>我们之前说过，布尔类型在内存中被表示的时候，是采用了0或者1来表示的，因此我们的布尔类型也有人将其归类到数字类型，只有两个值0和1，True就是1，False就是0。并且它们是被当作0和1来处理的，True+1的结果就是2</p><p>None属于nonetype类型，是nonetype数据类型的唯一值</p><p>所有<strong>有值的变量</strong>，不管是数字，字符串，列表，还是字典，<strong>直接用于判断的时候，除了0和None都会被认作为True</strong></p><p><strong>0、None、空字符串、空列表、空字典都是False</strong></p><h2 id="直接引用和间接引用"><a href="#直接引用和间接引用" class="headerlink" title="直接引用和间接引用"></a>直接引用和间接引用</h2><p>我们来看一段代码，我们在一个列表里，引用一个变量</p><img src="/post/40389/Image(11).png" class="" title="This is a picture"><p>在列表info里的变量是间接引用，我们也可以用info[0]访问到name这个变量，但是这时候是间接引用，我们如何证明这两个变量是同一个呢？很简单，看看id是不是同一个就可以了。</p><img src="/post/40389/Image(12).png" class="" title="This is a picture"><p>说明我们访问的值是同一个，info[0]和name都指向了同一片内存空间。这就是间接引用和直接引用</p><h2 id="列表在内存中的存储方式"><a href="#列表在内存中的存储方式" class="headerlink" title="列表在内存中的存储方式"></a>列表在内存中的存储方式</h2><p>我们来看一个列表</p><div class="code-wrapper"><pre><code class="hljs python">info = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]</code></pre></div><p>我画了一张图来说明这个列表在内存中的存储方式</p><img src="/post/40389/Image(13).png" class="" title="This is a picture"><p>首先，我们的列表在内存中开辟一片空间，空间内0号索引位存放着“a”的内存地址，这个内存地址肯定指向的是“a”，然后这一整个列表和info这个变量所绑定。</p><p>因此，字典在内存的存储方式也类似，只是把索引变成了key。</p><h4 id="一个问题🤔-在如下代码的情况下，我们print-info-0-的结果是什么？"><a href="#一个问题🤔-在如下代码的情况下，我们print-info-0-的结果是什么？" class="headerlink" title="一个问题🤔 在如下代码的情况下，我们print(info[0])的结果是什么？"></a>一个问题🤔 在如下代码的情况下，我们print(info[0])的结果是什么？</h4><img src="/post/40389/Image(14).png" class="" title="This is a picture"><div class="code-wrapper"><pre><code class="hljs other">张xx</code></pre></div><div class="code-wrapper"><pre><code class="hljs other">李xx</code></pre></div><p>没错，答案仍然是“张xx”</p><p><strong>分析：</strong>我们来看这个列表在内存的存放方式</p><img src="/post/40389/Image(15).png" class="" title="This is a picture"><p>在代码还没执行到 <code>name=‘李xx‘</code> 的时候，我们“张xx”的引用计数就是2，当代码执行到 <code>name=’李xx‘</code>  的时候，我们name被重新指向了一个新的值，此时我们info内0索引位还存着原来“张xx”的内存地址，这个变量的引用计数就还是1，所以不会被<strong>垃圾回收机制</strong>回收。我们也没有在info的列表里修改其对应关系，所以 info[0] 指向的仍然还是“张xx”而不是“李xx”。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>我们学过int类型，float类型，str类型，list类型，dict类型，我们都可以使用类型名(变量)，来实现类型转换，例如<code>int(‘221’)</code> 就是将字符串类型的221转成整型的221。当然其他类型转换也是大同小异。这里不详细展开了。</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Python的进制转换方法</span><span class="hljs-comment"># 十进制转二进制</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-number">222</span>))  <span class="hljs-comment"># 0b11011110</span><span class="hljs-comment"># 十进制转八进制</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">oct</span>(<span class="hljs-number">222</span>))  <span class="hljs-comment"># 0o336</span><span class="hljs-comment"># 十进制转十六进制</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-number">222</span>))  <span class="hljs-comment"># 0xde</span><span class="hljs-comment"># 二进制转十进制(传入第二个参数，说明我们传入的是二进制)</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0b11011110&#x27;</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 222</span><span class="hljs-comment"># 二进制转八进制(传入第二个参数，说明我们传入的是八进制)</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0o336&#x27;</span>, <span class="hljs-number">8</span>)) <span class="hljs-comment"># 222</span><span class="hljs-comment"># 二进制转十六进制(传入第二个参数，说明我们传入的是十六进制)</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0xde&#x27;</span>, <span class="hljs-number">16</span>))  <span class="hljs-comment"># 222</span></code></pre></div><p>懂得进制转换就行了，这只是一种方式。</p><p>至此Python变量和基本数据类型就讲完了，后面还有一份“[[基本数据类型（详）]]基本数据类型（详）”讲关于这些数据类型的操作。<strong>要着重理解变量在内存中的存储方式，这会对你对计算机的底层理解更加深刻。</strong></p>]]></content>
    
    
    <categories>
      
      <category> Python教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>功能测试</title>
    <link href="/post/19510/"/>
    <url>/post/19510/</url>
    
    <content type="html"><![CDATA[<h1 id="功能测试用例"><a href="#功能测试用例" class="headerlink" title="功能测试用例"></a>功能测试用例</h1><p><strong>直接测试项目</strong><br>UI测试，首页按钮功能测试，排序，列表显示。<br><strong>可以直接复制粘贴</strong><br>资产类别&#x2F;品牌&#x2F;取得方式（新增、修改、启用、禁用）<br>⬆️资产管理员只需要（UI测试、排序、显示、首页按钮功能测试）<br><strong>需要修改部分条件</strong><br>资产入库、资产借还、资产转移、资产维修（需要稍微修改一下部分条件）<br><strong>需要查询测试</strong><br>超级管理员：供应商、存放地点<br>资产管理员：供应商、存放地点、人员管理、资产入库、资产借还、资产转移、资产维修、资产报废、资产盘点、资产申购<br><strong>需要翻页测试</strong><br>人员管理、资产借还、资产入库、资产转移、资产维修、资产报废<br>（记录大于10条要翻页）<br>翻页测试用例：</p><ol><li>列表页数据小于10条；查看翻页功能；不显示翻页</li><li>列表页数据大于10条；查看翻页功能；显示翻页功能，首页，页码，末页，&gt;，&lt;</li><li>大于10条；当前为第一页；首页无法点击，当前页码高亮显示</li><li>大于10条；当前为最后一页；末页无法点击，当前页码高亮显示</li><li>大于10条；当前不为第一页，点击&lt;；跳转到对应页面，页码高亮显示</li><li>大于10条；当前不为第一页，点击&gt;；跳转到对应页面，页码高亮显示</li><li>大于10条；当前不为首页，点击“首页”；跳转到对应首页，页码高亮显示</li><li>大于10条；当前不为末页，点击“末页”；跳转到对应末页，页码高亮显示</li><li>大于10条；点击页码；跳转到对应页面，页码高亮显示</li><li>大于10条；输入查询条件，点击翻页；翻页功能正常，查询条件保留</li></ol><p><strong>查看***详情</strong><br>供应商、存放地点<br>资产借还（查看借用单详情）<br>资产转移（查看转移单详情）<br>资产申购（查看申购单详情）</p>]]></content>
    
    
    <categories>
      
      <category>软测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弹性盒布局</title>
    <link href="/post/60480/"/>
    <url>/post/60480/</url>
    
    <content type="html"><![CDATA[<h1 id="弹性盒布局"><a href="#弹性盒布局" class="headerlink" title="弹性盒布局"></a>弹性盒布局</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>弹性盒布局又叫做 Flexible Box，通常被叫做为 flexbox，是一种一维的布局模型。<br>flexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另外一个二维布局  CSS Grid Layout，可以同时处理行和列上的布局。</p><h2 id="FlexBox-的两根轴线"><a href="#FlexBox-的两根轴线" class="headerlink" title="FlexBox 的两根轴线"></a>FlexBox 的两根轴线</h2><p>首先在 flex 布局中，我们有两根轴线——主轴和交叉轴，主轴是通过使用 flex-direction 定义的，另一根轴垂直于它。</p><h3 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h3><p>主轴取值有如下四个</p><ul><li><code>row</code></li><li><code>row-reverse</code></li><li><code>column</code></li><li><code>column-reverse</code><br>  如果是 <code>row</code> 或者 <code>row-reverse</code> 的时候，主轴将会沿着 inline 的方向延伸。<br>  如果是 <code>column</code> 或者 <code>column-reverse</code>的时候，主轴将会以上下方向延伸，也就是 block 排列的方向。</li></ul><h3 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h3><p>交叉轴是垂直于主轴的，flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。</p><h2 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h2><p>在过去 CSS 的书写模式主要被认为是水平的，从左到右。现代的布局方式涵盖了书写模式的范围，因为有些国家是从右往左书写的，<br>如果 <code>flex-direction</code> 是 <code>row</code> ，并且在书写英文的情况下，那么主轴的起始线是左边，终止线是右边。<br>如果书写阿拉伯文，则主轴的起始线为右边，终止线为左边。<br><br>在这两种情况下，交叉轴的起始线是 flex 容器的顶部，终止线是底部，因为这两种语言都是水平书写模式。</p><h2 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h2><p>文档中采用了 flexbox 的区域被称为 flex 容器。将容器的<code>display</code>属性改为<code>flex</code>或者<code>inline-flex</code>即可。默认的 flex 容器有如下属性。</p><ul><li>元素排列为一行，因为 flex-direction 属性初始值为 row。</li><li>元素从主轴的起始线开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。  <img src="/post/60480/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80-20240106143416555.png" class="" title="这是一张图片">  我们可以看上图，在上图中我们设置<code>container</code>的宽度为 800px，而子元素的宽度为 100px，可以看到并没有被拉伸。</li><li>元素会被拉伸来填充交叉轴的大小。</li><li><code>flex-basis</code>的属性为<code>auto</code> 。</li><li><code>flex-wrap</code> 属性为<code>nowrap</code> 。</li></ul><p>会让元素呈线性排列，并且将自己的大小作为主轴大小，如果元素超出容器，他将会溢出而不会换行。如果一些元素的高度比其他的元素高，则元素会沿交叉轴被拉伸来填满大小。</p><h2 id="用-flex-wrap-实现多行-Flex-容器"><a href="#用-flex-wrap-实现多行-Flex-容器" class="headerlink" title="用 flex-wrap 实现多行 Flex 容器"></a>用 flex-wrap 实现多行 Flex 容器</h2><p>虽然<code>flexbox</code>为一维模型，但我们可以使 flex 应用到多行，在这样做的时候，应该将每一行看作为一个新的<strong>flex 容器</strong>。任何空间分布都将会在该行上发生，而不影响改空间分布的其他行。<br><br>我们需要为<code>flex-wrap</code>属性添加一个属性值<code>wrap</code>。<br>设置完成后，这样你就会因为元素太多太大，而无法全部显示在一行，则会换行显示。当盒子的宽度<strong>不足以放下一个完整子元素</strong>的时候，将会换行。</p><h2 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h2><p>当然也可以将<code>flex-direction</code>和<code>flex-wrap</code>组合简写为一个属性<code>flex-flow</code> 第一个值为<code>flex-direction</code> 第二个值为 <code>flex-wrap</code></p><h2 id="flex-元素上的属性"><a href="#flex-元素上的属性" class="headerlink" title="flex 元素上的属性"></a>flex 元素上的属性</h2><p>为了更好的控制 flex 元素，有三个属性可以作用于他们：</p><ul><li><code>flex-grow</code></li><li>&#96;felx-shrink</li><li>&#96;flex-basis</li></ul><p>在此之前，我们需要了解<strong>可用空间</strong>这个概念，这些概念其实就是改变了 flex 容器中可用空间的行为。<br>假设，在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占用 300px 的宽，剩下的 200px 的可用空间。在默认情况下，flexbox 将会把这 200px 的空间留在最后一个元素的后面。<br><br>如果期望这些元素能够自动地扩展去填充满剩下的空间，那我们需要去控制可用空间在这几个元素之间如何分配，这就是元素上 flex 属性需要做的事情。</p><h2 id="Flex-元素属性：flex-basis"><a href="#Flex-元素属性：flex-basis" class="headerlink" title="Flex 元素属性：flex-basis"></a>Flex 元素属性：<code>flex-basis</code></h2><p><code>flex-basis</code>  定义了该元素的<strong>空间大小</strong>（<strong>the size of that item in terms of the space</strong>），flex 容器里除了元素所占的空间以外的富余空间就是<strong>可用空间</strong> available space。该属性的默认值是  <code>auto</code> 。此时，浏览器会检测这个元素是否具有确定的尺寸。在上面的例子中，所有元素都设定了宽度（width）为 100px，所以  <code>flex-basis</code>  的值为 100px。(也就是会自动覆盖 width)<br>如果没有给元素设定尺寸，<code>flex-basis</code>  的值采用元素内容的尺寸。这就解释了：我们给只要给 Flex 元素的父元素声明  <code>display: flex</code> ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</p><h2 id="Flex-元素：flex-grow"><a href="#Flex-元素：flex-grow" class="headerlink" title="Flex 元素：flex-grow"></a>Flex 元素：<code>flex-grow</code></h2><p>可以简单理解为 Android 开发中 <code>layout_weight</code> 一致。<br><br><code>flex-grow</code>  若被赋值为一个正整数，flex 元素会以  <code>flex-basis</code>  为基础，沿<strong>主轴方向增长</strong>尺寸。这会使该元素延展，并占据此方向轴上的可用空间（available space）。如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。</p><p>如果我们给上例中的所有元素设定  <code>flex-grow</code>  值为 1，容器中的可用空间会被这些元素<strong>平分</strong>。它们会延展以填满容器主轴方向上的空间。</p><p>flex-grow 属性可以按比例分配空间。如果第一个元素  <code>flex-grow</code>  值为 2，其他元素值为 1，则第一个元素将占有 2&#x2F;4（上例中，即为 200px 中的 100px）, 另外两个元素各占有 1&#x2F;4（各 50px）。</p><h2 id="Flex-元素：flex-shrink"><a href="#Flex-元素：flex-shrink" class="headerlink" title="Flex 元素：flex-shrink"></a>Flex 元素：<code>flex-shrink</code></h2><p>会以 <code>flex-basis</code> 为基础，沿着主轴方向收缩尺寸。会使得该元素收缩。<br>如果设置不同的容器大小，则会按照比例均分<code>flex-basis</code>。</p><p><code>flex-grow</code>属性是处理 flex 元素在主轴上增加空间的问题，相反<code>flex-shrink</code>属性是处理 flex 元素收缩的问题。如果我们的容器中没有足够排列 flex 元素的空间，那么可以把 flex 元素<code>flex-shrink</code>属性设置为正整数来缩小它所占空间到<code>flex-basis</code>以下。与<code>flex-grow</code>属性一样，可以赋予不同的值来控制 flex 元素收缩的程度——给<code>flex-shrink</code>属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。</p><h2 id="元素之间的对齐和空间分配"><a href="#元素之间的对齐和空间分配" class="headerlink" title="元素之间的对齐和空间分配"></a>元素之间的对齐和空间分配</h2><p>FlexBox 的一个关键特性是能够设置 flex 元素沿主轴方向和交叉轴方向的对齐方式，以及他们之间的空间分配。</p><p><code>align-items</code><br>这个属性的初始值为 stretch，这就是为什么 flex 元素会默认被拉伸到最高元素的高度，实际上他们是被拉伸填满 flex 容器——最高的元素定义了容器的高度。它可以是如下值</p><ul><li><code>stretch</code> 默认值</li><li><code>flex-start</code> 使得 flex 元素按照 flex 容器的顶部对齐</li><li><code>flex-end</code> 使它们按 flex 容器的下部对齐</li><li><code>center</code> 是他们居中对齐</li></ul><p><code>justify-content</code><br>这个属性的初始值为 <code>flex-start</code> 元素从容器的起始线排列，设置为 <code>flex-end</code> 从终止线开始排列。或者选择 <code>center</code> ，在中间排列。<br>也可以将值设置为<code>space-between</code> ，将元素排列好后的剩余空间拿出来，平均分配到元素之间，使得元素之间的间隔相等。或者使用<code>space-around</code> 使得每个元素的左右空间相等。</p><ul><li><code>flex-grow</code>：该元素获得（伸张）多少正可用空间（positive free space）？</li><li><code>flex-shrink</code>：该元素要消除（收缩）多少负可用空间（negative free space）？</li><li><code>flex-basis</code>：在该元素未伸张和收缩之前，它的大小是多少？</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
